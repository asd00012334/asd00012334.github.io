{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/current/source/css/article.styl","path":"css/article.styl","modified":1,"renderable":1},{"_id":"themes/current/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/current/source/css/mixins.styl","path":"css/mixins.styl","modified":1,"renderable":1},{"_id":"themes/current/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/current/source/css/variables.styl","path":"css/variables.styl","modified":1,"renderable":1},{"_id":"themes/current/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":1},{"_id":"themes/current/source/img/favicon_clover/about.txt","path":"img/favicon_clover/about.txt","modified":1,"renderable":1},{"_id":"themes/current/source/img/favicon_clover/android-chrome-192x192.png","path":"img/favicon_clover/android-chrome-192x192.png","modified":1,"renderable":1},{"_id":"themes/current/source/img/favicon_clover/android-chrome-512x512.png","path":"img/favicon_clover/android-chrome-512x512.png","modified":1,"renderable":1},{"_id":"themes/current/source/img/favicon_clover/apple-touch-icon.png","path":"img/favicon_clover/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/current/source/img/favicon_clover/favicon-16x16.png","path":"img/favicon_clover/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/current/source/img/favicon_clover/favicon-32x32.png","path":"img/favicon_clover/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/current/source/img/favicon_clover/favicon.ico","path":"img/favicon_clover/favicon.ico","modified":1,"renderable":1},{"_id":"themes/current/source/img/favicon_clover/site.webmanifest","path":"img/favicon_clover/site.webmanifest","modified":1,"renderable":1},{"_id":"themes/current/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":1},{"_id":"themes/current/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":1},{"_id":"source/tags/debug.log","path":"tags/debug.log","modified":1,"renderable":0},{"_id":"themes/current/source/img/ghent-bg.jpg","path":"img/ghent-bg.jpg","modified":1,"renderable":1},{"_id":"themes/current/source/img/profile_pic.jpg","path":"img/profile_pic.jpg","modified":1,"renderable":1},{"_id":"themes/current/source/img/ghent.jpg","path":"img/ghent.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/current/.git","hash":"cc1df2f4d5a18da2296a01e2af6c5ac55e31fa59","modified":1641165017818},{"_id":"themes/current/LICENSE","hash":"34ac5e147727699d1bbc346b014f2e0bdfbb0947","modified":1641165019773},{"_id":"themes/current/README.md","hash":"779e999931169acdbabf43ab0e70471e8631583a","modified":1641165492275},{"_id":"themes/current/_config.yml","hash":"6ce8bdcc995c4137fa564b32bc99c251b2977989","modified":1716833774126},{"_id":"source/_posts/Free-Monoid-and-McMillan-s-Inequality.md","hash":"e1a76a1ead97d76ed8fc4ad257ac044aadf58ec4","modified":1716838180199},{"_id":"source/_posts/Heirarchy-Theorem.md","hash":"94ed5e278206008d177e15b2ccbfc1fe5a348f6e","modified":1716838180199},{"_id":"source/_posts/ICPC-Japan-Yokohama-回顧.md","hash":"1b5c70a20d97d1f6df922749d00d8afe15d632eb","modified":1716838180199},{"_id":"source/_posts/Miller-Rabin-Primality-Test.md","hash":"8b8abc5c926da712491175cb2775fcade49c1848","modified":1716838180199},{"_id":"source/_posts/On-the-Communication-Complexity-of-EQ.md","hash":"34b0f4f6c7fc9433ae895cb5c0fa7ad2ba5737c4","modified":1716838180199},{"_id":"source/_posts/On-the-Generalised-Eigenvalue-Problems.md","hash":"97464cefa664f189a4e63a01308c7fac01c29232","modified":1716838180199},{"_id":"source/_posts/Optimality-of-Grover-Search.md","hash":"b2405b40029add496503453ab99801dd025f34d1","modified":1716838180199},{"_id":"source/_posts/Prologue-UIUC.md","hash":"eaee368cbd4f5bcde4878f628a0898d93d46ad7d","modified":1716838180199},{"_id":"source/_posts/Quick-Note-on-the-Continued-Fraction.md","hash":"f40485037468c483392886517deb5fe8f5984e4f","modified":1716838180199},{"_id":"source/_posts/Randomized-Primality-Test.md","hash":"2fe946c384ef809e9f46043274904334c3931cd6","modified":1716838180199},{"_id":"source/_posts/新開張.md","hash":"0a6066384d08874ef88140ed64a08295d1f55d1c","modified":1716838180247},{"_id":"source/about/index.md","hash":"50eddef55815f280cda0ac6370047975b08b6de9","modified":1716838180247},{"_id":"source/tags/index.md","hash":"216a173ebb392c2480e12cd5f45826094836ae5e","modified":1716838180248},{"_id":"source/categories/index.md","hash":"59d13b008c86daf169d96f3c17c88393e22fb1fa","modified":1716838180247},{"_id":"themes/current/languages/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1641165019774},{"_id":"themes/current/languages/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1641165019774},{"_id":"themes/current/languages/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1641165019774},{"_id":"themes/current/languages/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1641165019774},{"_id":"themes/current/languages/fr.yml","hash":"10e3529b8492d7a7601d5b35b44d8fc9e8ea8d1b","modified":1641165019774},{"_id":"themes/current/languages/ko.yml","hash":"b52f84a08d877b545751441c45a1961105eb4372","modified":1641165019774},{"_id":"themes/current/languages/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1641165019775},{"_id":"themes/current/languages/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1641165019775},{"_id":"themes/current/languages/pt.yml","hash":"6a31d548092af8af9f25d859063b0589c23ce13a","modified":1641165019775},{"_id":"themes/current/languages/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1641165019775},{"_id":"themes/current/languages/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1641165019775},{"_id":"themes/current/languages/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1641165019776},{"_id":"themes/current/layout/archive.ejs","hash":"c3aa4a76ee8b59b0e12ddbe951a9852176058eac","modified":1641165492276},{"_id":"themes/current/layout/index.ejs","hash":"7dfdd9347f14b782d305a70f9ddb696ee1bb3864","modified":1641165492276},{"_id":"themes/current/layout/layout.ejs","hash":"acc791dc4346c135ce4cac3cdeba6f96708115e5","modified":1641165019779},{"_id":"themes/current/layout/page.ejs","hash":"b585761947e289f0e37380780cfdebee0674c378","modified":1641165492277},{"_id":"themes/current/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1641165019779},{"_id":"themes/current/layout/_partial/after-footer.ejs","hash":"f199b6e0039a7e9f840b8fbb9971fbd673ba5ce3","modified":1641165019776},{"_id":"themes/current/layout/_partial/article-archive.ejs","hash":"75b9b24c226eda4884752a868177b590d3e8b06f","modified":1641165019776},{"_id":"themes/current/layout/_partial/article-categories.ejs","hash":"b494e4a50f63d66e545da449af18a7198a057bd6","modified":1641165019776},{"_id":"themes/current/layout/_partial/article-full.ejs","hash":"b71cc571f43127bc0307557a201b99e7eb015fc7","modified":1641165492276},{"_id":"themes/current/layout/_partial/article-index.ejs","hash":"ad112adf312337c60d436fdd127e948fe81b3dd1","modified":1641165019777},{"_id":"themes/current/layout/_partial/article-tags.ejs","hash":"12524df0c1ce5136a8f88cea2fe550f9e1b47b19","modified":1641165019777},{"_id":"themes/current/layout/_partial/comments.ejs","hash":"5cafed11b6cfbf22e83674676c0edc6c4420cc0d","modified":1641165019777},{"_id":"themes/current/layout/_partial/footer.ejs","hash":"bb4d7aa04c9fc2c973f8d8c6c65991011a3d2957","modified":1716767455384},{"_id":"themes/current/layout/_partial/gallery.ejs","hash":"15e9562d0f6146e25e22856693d1312cd3ade4af","modified":1641165019777},{"_id":"themes/current/layout/_partial/google-analytics.ejs","hash":"b287b7f66a53b51c7cd872ad1b15dfd20fb3e35d","modified":1641165019778},{"_id":"themes/current/layout/_partial/head.ejs","hash":"adcb0c065f28378922aaf80961a874201694976b","modified":1716768280430},{"_id":"themes/current/layout/_partial/menu.ejs","hash":"6bd6a1a7839cf092aa928c59a601270248f786d1","modified":1716767302614},{"_id":"themes/current/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1641165019778},{"_id":"themes/current/layout/_partial/tag-category-index.ejs","hash":"008b4ed0b6fd6dc81bc0655ccc46e43eb310706b","modified":1641165019778},{"_id":"themes/current/source/css/article.styl","hash":"768418ecaa2ff17f6fa81d72096627e05579fe93","modified":1641165019780},{"_id":"themes/current/source/css/base.styl","hash":"8948fe328bd11a06172b5024b4580408e44562ba","modified":1716758165575},{"_id":"themes/current/source/css/mixins.styl","hash":"cf700a1c1c62b17d35a8f7500bf1a32d9bc6ab6a","modified":1641165019780},{"_id":"themes/current/source/css/style.styl","hash":"7200d572751c1f5888b3d0df25bf503a3f31ca2d","modified":1641165019780},{"_id":"themes/current/source/css/variables.styl","hash":"0a0d77022f576c1c1ce2db2baa39df090b1b671f","modified":1716757035362},{"_id":"themes/current/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1641165019781},{"_id":"themes/current/source/img/favicon_clover/about.txt","hash":"228d50640d8cb4b1123a97d0045f4a81d87edb89","modified":1716823676000},{"_id":"themes/current/source/img/favicon_clover/android-chrome-192x192.png","hash":"48c5a8bdf30a1c08afb63e76eb2f38391238688d","modified":1716823676000},{"_id":"themes/current/source/img/favicon_clover/android-chrome-512x512.png","hash":"dd45e028d68a5807e60b2eda6f4998f8159a66df","modified":1716823676000},{"_id":"themes/current/source/img/favicon_clover/apple-touch-icon.png","hash":"20b57dc69f0c9ade7b6bf1ff0b94be9df199ba18","modified":1716823676000},{"_id":"themes/current/source/img/favicon_clover/favicon-16x16.png","hash":"ecf36d1d9e0142366fd1912a2a646fdf3da597d1","modified":1716823676000},{"_id":"themes/current/source/img/favicon_clover/favicon-32x32.png","hash":"382addc9ec6dddbd5d1a4fc568340171c2ca887c","modified":1716823676000},{"_id":"themes/current/source/img/favicon_clover/favicon.ico","hash":"88b93829185123d234d96edb492d4e93b11a3782","modified":1716823676000},{"_id":"themes/current/source/img/favicon_clover/site.webmanifest","hash":"bf31baf91bdd2fcde24a45e3f2a1be33733c6f69","modified":1716823676000},{"_id":"themes/current/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1641165019783},{"_id":"themes/current/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1641165019782},{"_id":"source/tags/debug.log","hash":"f7edce39bdbfc1f52b00522a192fc9e60355840c","modified":1716838180248},{"_id":"themes/current/source/img/ghent-bg.jpg","hash":"015171c0c3024faee39e0b77da9add2829670ffa","modified":1716757647416},{"_id":"themes/current/source/img/profile_pic.jpg","hash":"37d2975fcd73c434818c41cb78a9faf526807de5","modified":1716832671732},{"_id":"themes/current/source/img/ghent.jpg","hash":"8c346af43a52afccc1bb87cd49f474f324480884","modified":1716755550776},{"_id":"source/_posts/debug.log","hash":"b565f658291901315bf95577d71ed813765e6f2b","modified":1716838180246}],"Category":[],"Data":[],"Page":[{"title":"About Me","type":"about me","date":"2024-05-27T19:29:40.247Z","_content":"\nGoedendag! I am Yu-Hsuan Huang (右萱 黃) from Taiwan, currently a PhD student working on post-quantum cryptography with [Serge Fehr](https://homepages.cwi.nl/~fehr/) at [Centrum Wiskunde & Informatica (CWI)](https://www.cwi.nl/), the dutch center of mathematics (wiskunde) and computer science (informatica), also known as the [origin of Python](https://www.cwi.nl/en/news/25-years-of-python-at-cwi/). Before joining CWI, I finished my BSc and MSc in Computer Science at [National Chiao-Tung University (台灣交通大學)](https://en.wikipedia.org/wiki/National_Chiao_Tung_University).\n\n<img src=\"/img/profile_pic.jpg\">\n\nMore generally, my research interests lie in theoretical computer science in the presence of quantum computation. Works of mine typically involve pin-pointing (in particular, quantum) securities of certain cryptographic constructions or methodologies, which comes in the form of formal mathematical proofs.\n\n\n\n\n","source":"about/index.md","raw":"---\ntitle: About Me \ntype: \"about me\"\ndate:\n---\n\nGoedendag! I am Yu-Hsuan Huang (右萱 黃) from Taiwan, currently a PhD student working on post-quantum cryptography with [Serge Fehr](https://homepages.cwi.nl/~fehr/) at [Centrum Wiskunde & Informatica (CWI)](https://www.cwi.nl/), the dutch center of mathematics (wiskunde) and computer science (informatica), also known as the [origin of Python](https://www.cwi.nl/en/news/25-years-of-python-at-cwi/). Before joining CWI, I finished my BSc and MSc in Computer Science at [National Chiao-Tung University (台灣交通大學)](https://en.wikipedia.org/wiki/National_Chiao_Tung_University).\n\n<img src=\"/img/profile_pic.jpg\">\n\nMore generally, my research interests lie in theoretical computer science in the presence of quantum computation. Works of mine typically involve pin-pointing (in particular, quantum) securities of certain cryptographic constructions or methodologies, which comes in the form of formal mathematical proofs.\n\n\n\n\n","updated":"2024-05-27T19:29:40.247Z","path":"about/index.html","comments":1,"layout":"page","_id":"clwpi3moy0001bx4rbk6hfwg2","content":"<p>Goedendag! I am Yu-Hsuan Huang (右萱 黃) from Taiwan, currently a PhD student working on post-quantum cryptography with <a href=\"https://homepages.cwi.nl/~fehr/\" target=\"_blank\" rel=\"noopener\">Serge Fehr</a> at <a href=\"https://www.cwi.nl/\" target=\"_blank\" rel=\"noopener\">Centrum Wiskunde &amp; Informatica (CWI)</a>, the dutch center of mathematics (wiskunde) and computer science (informatica), also known as the <a href=\"https://www.cwi.nl/en/news/25-years-of-python-at-cwi/\" target=\"_blank\" rel=\"noopener\">origin of Python</a>. Before joining CWI, I finished my BSc and MSc in Computer Science at <a href=\"https://en.wikipedia.org/wiki/National_Chiao_Tung_University\" target=\"_blank\" rel=\"noopener\">National Chiao-Tung University (台灣交通大學)</a>.</p>\n<p><img src=\"/img/profile_pic.jpg\"></p>\n<p>More generally, my research interests lie in theoretical computer science in the presence of quantum computation. Works of mine typically involve pin-pointing (in particular, quantum) securities of certain cryptographic constructions or methodologies, which comes in the form of formal mathematical proofs.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Goedendag! I am Yu-Hsuan Huang (右萱 黃) from Taiwan, currently a PhD student working on post-quantum cryptography with <a href=\"https://homepages.cwi.nl/~fehr/\" target=\"_blank\" rel=\"noopener\">Serge Fehr</a> at <a href=\"https://www.cwi.nl/\" target=\"_blank\" rel=\"noopener\">Centrum Wiskunde &amp; Informatica (CWI)</a>, the dutch center of mathematics (wiskunde) and computer science (informatica), also known as the <a href=\"https://www.cwi.nl/en/news/25-years-of-python-at-cwi/\" target=\"_blank\" rel=\"noopener\">origin of Python</a>. Before joining CWI, I finished my BSc and MSc in Computer Science at <a href=\"https://en.wikipedia.org/wiki/National_Chiao_Tung_University\" target=\"_blank\" rel=\"noopener\">National Chiao-Tung University (台灣交通大學)</a>.</p>\n<p><img src=\"/img/profile_pic.jpg\"></p>\n<p>More generally, my research interests lie in theoretical computer science in the presence of quantum computation. Works of mine typically involve pin-pointing (in particular, quantum) securities of certain cryptographic constructions or methodologies, which comes in the form of formal mathematical proofs.</p>\n"},{"title":"Tags","type":"tags","date":"2018-11-16T18:43:18.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ntype: \"tags\"\ndate: 2018-11-16 19:43:18\n---\n","updated":"2024-05-27T19:29:40.248Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clwpi3moz0003bx4ramgv2i1m","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Categories","type":"categories","date":"2018-11-16T18:52:11.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ntype: \"categories\"\ndate: 2018-11-16 19:52:11\n---\n","updated":"2024-05-27T19:29:40.247Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clwpi3mp10005bx4r9pxzwilk","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Free Monoid and McMillan's Inequality","date":"2019-01-20T22:21:09.000Z","_content":"<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script\n    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>\n</script>\n\nIn theory of computation, or formal language, we usually define an alphabet to be some arbitrary finite (non-empty) set. This of course shows no problem along with construction of strings that is (usually) as below.\n\nGiven a finite non-empty set $\\Sigma$, a string $s$ is defined as a sequence of its elements,\n$$\ns=\\sigma_1\\sigma_2...\\sigma_r\\in\\Sigma^*.\n$$\n\nA language is defined as collection of strings,\n\n$$\nL\\subseteq\\Sigma^*.\n$$\nWe took some advantages of the notation, one might just implicitly accept that there's a binary operation that concatenate two different strings so that we don't have to write out the comma's in between.\n\n### Alphabet\n\nIt turns out we could as well integrate the above definition based on \"concatenation\" only, which in this context refers to a *free monoid* operation. A monoid refer to a binary algebraic structure $(M,*)$ that satisfies:\n- Associativity: $(ab)c=a(bc)$\n- Identity's existence: $\\forall a\\in M:ea=ae=a$\n\nA monoid is called free if there's a basis $B=\\{b_1,...,b_r\\}$ that generates the whole set.\n$$\n\\forall m\\in M\\exists l_i's: b_{l_1}b_{l_2}...b_{l_k}=m,\n$$\nand the representation is unique, i.e.\n$$\nb_{l_1}b_{l_2}...b_{l_r}=b_{k_1}b_{k_2}...b_{k_r'}\\iff r=r' \\land \\forall i:l_i=k_i\n$$\nIt is also worth noting that basis of a free monoid must be unique, and the cardinality of $B$ is called its free-monoid rank. Therefore we could just refer to \"alphabet\" as basis of some free monoid. Following that, we immediately obtain the alphabet of sub-monoid, for instance, if $\\Sigma=\\{0,1\\}$, then $\\{0,01\\}$ is an alphabet while $\\{0,1,01\\}$ is not.\n\n### McMillan's Inequality\n\nMcMillan's inequality is necessary for a set of strings to be an alphabet. Suppose $S=\\{s_1,s_2,...,s_k\\}\\subseteq\\Sigma^*$ is an alphabet. For $l_i:=|s_i|$ and $|\\Sigma|=r$ we have,\n$$\n\\sum_{1\\leq i\\leq k} r^{-l_i} \\leq 1.\n$$\n\n#### proof.\n\nFirst we took $n$-power and expand the left-hand term, suppose the index of $r$ ranges from $n$ to $nL=n\\max\\{l_i\\}$.\n$$\n(\\sum_{1\\leq i\\leq k} r^{-l_i})^n = \\sum_{n\\leq i\\leq nL} a_ir^{-i}.\n$$\nwhere $a_i$ is the number of ways to construct a length $i$ string from $n$ elements of $S$. Since $a_i\\leq r^i$, we have\n$$\n(\\sum_{1\\leq i\\leq k} r^{-l_i})^n\\leq n(L-1).\n$$\nIf the McMillan's inequality does not hold, as $n\\rightarrow\\infty$, the above inequality will be violated since the left-hand side grows much faster than the right hand side. ${}_\\square$\n\n\n\n","source":"_posts/Free-Monoid-and-McMillan-s-Inequality.md","raw":"---\ntitle: Free Monoid and McMillan's Inequality\ndate: 2019-01-20 23:21:09\ntags:\n---\n<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script\n    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>\n</script>\n\nIn theory of computation, or formal language, we usually define an alphabet to be some arbitrary finite (non-empty) set. This of course shows no problem along with construction of strings that is (usually) as below.\n\nGiven a finite non-empty set $\\Sigma$, a string $s$ is defined as a sequence of its elements,\n$$\ns=\\sigma_1\\sigma_2...\\sigma_r\\in\\Sigma^*.\n$$\n\nA language is defined as collection of strings,\n\n$$\nL\\subseteq\\Sigma^*.\n$$\nWe took some advantages of the notation, one might just implicitly accept that there's a binary operation that concatenate two different strings so that we don't have to write out the comma's in between.\n\n### Alphabet\n\nIt turns out we could as well integrate the above definition based on \"concatenation\" only, which in this context refers to a *free monoid* operation. A monoid refer to a binary algebraic structure $(M,*)$ that satisfies:\n- Associativity: $(ab)c=a(bc)$\n- Identity's existence: $\\forall a\\in M:ea=ae=a$\n\nA monoid is called free if there's a basis $B=\\{b_1,...,b_r\\}$ that generates the whole set.\n$$\n\\forall m\\in M\\exists l_i's: b_{l_1}b_{l_2}...b_{l_k}=m,\n$$\nand the representation is unique, i.e.\n$$\nb_{l_1}b_{l_2}...b_{l_r}=b_{k_1}b_{k_2}...b_{k_r'}\\iff r=r' \\land \\forall i:l_i=k_i\n$$\nIt is also worth noting that basis of a free monoid must be unique, and the cardinality of $B$ is called its free-monoid rank. Therefore we could just refer to \"alphabet\" as basis of some free monoid. Following that, we immediately obtain the alphabet of sub-monoid, for instance, if $\\Sigma=\\{0,1\\}$, then $\\{0,01\\}$ is an alphabet while $\\{0,1,01\\}$ is not.\n\n### McMillan's Inequality\n\nMcMillan's inequality is necessary for a set of strings to be an alphabet. Suppose $S=\\{s_1,s_2,...,s_k\\}\\subseteq\\Sigma^*$ is an alphabet. For $l_i:=|s_i|$ and $|\\Sigma|=r$ we have,\n$$\n\\sum_{1\\leq i\\leq k} r^{-l_i} \\leq 1.\n$$\n\n#### proof.\n\nFirst we took $n$-power and expand the left-hand term, suppose the index of $r$ ranges from $n$ to $nL=n\\max\\{l_i\\}$.\n$$\n(\\sum_{1\\leq i\\leq k} r^{-l_i})^n = \\sum_{n\\leq i\\leq nL} a_ir^{-i}.\n$$\nwhere $a_i$ is the number of ways to construct a length $i$ string from $n$ elements of $S$. Since $a_i\\leq r^i$, we have\n$$\n(\\sum_{1\\leq i\\leq k} r^{-l_i})^n\\leq n(L-1).\n$$\nIf the McMillan's inequality does not hold, as $n\\rightarrow\\infty$, the above inequality will be violated since the left-hand side grows much faster than the right hand side. ${}_\\square$\n\n\n\n","slug":"Free-Monoid-and-McMillan-s-Inequality","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mov0000bx4r38id5m4p","content":"<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML\" async>\n</script>\n\n<p>In theory of computation, or formal language, we usually define an alphabet to be some arbitrary finite (non-empty) set. This of course shows no problem along with construction of strings that is (usually) as below.</p>\n<p>Given a finite non-empty set $\\Sigma$, a string $s$ is defined as a sequence of its elements,<br>$$<br>s=\\sigma_1\\sigma_2…\\sigma_r\\in\\Sigma^*.<br>$$</p>\n<p>A language is defined as collection of strings,</p>\n<p>$$<br>L\\subseteq\\Sigma^*.<br>$$<br>We took some advantages of the notation, one might just implicitly accept that there’s a binary operation that concatenate two different strings so that we don’t have to write out the comma’s in between.</p>\n<h3 id=\"Alphabet\"><a href=\"#Alphabet\" class=\"headerlink\" title=\"Alphabet\"></a>Alphabet</h3><p>It turns out we could as well integrate the above definition based on “concatenation” only, which in this context refers to a <em>free monoid</em> operation. A monoid refer to a binary algebraic structure $(M,*)$ that satisfies:</p>\n<ul>\n<li>Associativity: $(ab)c=a(bc)$</li>\n<li>Identity’s existence: $\\forall a\\in M:ea=ae=a$</li>\n</ul>\n<p>A monoid is called free if there’s a basis $B=\\{b_1,…,b_r\\}$ that generates the whole set.<br>$$<br>\\forall m\\in M\\exists l_i’s: b_{l_1}b_{l_2}…b_{l_k}=m,<br>$$<br>and the representation is unique, i.e.<br>$$<br>b_{l_1}b_{l_2}…b_{l_r}=b_{k_1}b_{k_2}…b_{k_r’}\\iff r=r’ \\land \\forall i:l_i=k_i<br>$$<br>It is also worth noting that basis of a free monoid must be unique, and the cardinality of $B$ is called its free-monoid rank. Therefore we could just refer to “alphabet” as basis of some free monoid. Following that, we immediately obtain the alphabet of sub-monoid, for instance, if $\\Sigma=\\{0,1\\}$, then $\\{0,01\\}$ is an alphabet while $\\{0,1,01\\}$ is not.</p>\n<h3 id=\"McMillan’s-Inequality\"><a href=\"#McMillan’s-Inequality\" class=\"headerlink\" title=\"McMillan’s Inequality\"></a>McMillan’s Inequality</h3><p>McMillan’s inequality is necessary for a set of strings to be an alphabet. Suppose $S=\\{s_1,s_2,…,s_k\\}\\subseteq\\Sigma^*$ is an alphabet. For $l_i:=|s_i|$ and $|\\Sigma|=r$ we have,<br>$$<br>\\sum_{1\\leq i\\leq k} r^{-l_i} \\leq 1.<br>$$</p>\n<h4 id=\"proof\"><a href=\"#proof\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>First we took $n$-power and expand the left-hand term, suppose the index of $r$ ranges from $n$ to $nL=n\\max\\{l_i\\}$.<br>$$<br>(\\sum_{1\\leq i\\leq k} r^{-l_i})^n = \\sum_{n\\leq i\\leq nL} a_ir^{-i}.<br>$$<br>where $a_i$ is the number of ways to construct a length $i$ string from $n$ elements of $S$. Since $a_i\\leq r^i$, we have<br>$$<br>(\\sum_{1\\leq i\\leq k} r^{-l_i})^n\\leq n(L-1).<br>$$<br>If the McMillan’s inequality does not hold, as $n\\rightarrow\\infty$, the above inequality will be violated since the left-hand side grows much faster than the right hand side. ${}_\\square$</p>\n","site":{"data":{}},"excerpt":"","more":"<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML\" async>\n</script>\n\n<p>In theory of computation, or formal language, we usually define an alphabet to be some arbitrary finite (non-empty) set. This of course shows no problem along with construction of strings that is (usually) as below.</p>\n<p>Given a finite non-empty set $\\Sigma$, a string $s$ is defined as a sequence of its elements,<br>$$<br>s=\\sigma_1\\sigma_2…\\sigma_r\\in\\Sigma^*.<br>$$</p>\n<p>A language is defined as collection of strings,</p>\n<p>$$<br>L\\subseteq\\Sigma^*.<br>$$<br>We took some advantages of the notation, one might just implicitly accept that there’s a binary operation that concatenate two different strings so that we don’t have to write out the comma’s in between.</p>\n<h3 id=\"Alphabet\"><a href=\"#Alphabet\" class=\"headerlink\" title=\"Alphabet\"></a>Alphabet</h3><p>It turns out we could as well integrate the above definition based on “concatenation” only, which in this context refers to a <em>free monoid</em> operation. A monoid refer to a binary algebraic structure $(M,*)$ that satisfies:</p>\n<ul>\n<li>Associativity: $(ab)c=a(bc)$</li>\n<li>Identity’s existence: $\\forall a\\in M:ea=ae=a$</li>\n</ul>\n<p>A monoid is called free if there’s a basis $B=\\{b_1,…,b_r\\}$ that generates the whole set.<br>$$<br>\\forall m\\in M\\exists l_i’s: b_{l_1}b_{l_2}…b_{l_k}=m,<br>$$<br>and the representation is unique, i.e.<br>$$<br>b_{l_1}b_{l_2}…b_{l_r}=b_{k_1}b_{k_2}…b_{k_r’}\\iff r=r’ \\land \\forall i:l_i=k_i<br>$$<br>It is also worth noting that basis of a free monoid must be unique, and the cardinality of $B$ is called its free-monoid rank. Therefore we could just refer to “alphabet” as basis of some free monoid. Following that, we immediately obtain the alphabet of sub-monoid, for instance, if $\\Sigma=\\{0,1\\}$, then $\\{0,01\\}$ is an alphabet while $\\{0,1,01\\}$ is not.</p>\n<h3 id=\"McMillan’s-Inequality\"><a href=\"#McMillan’s-Inequality\" class=\"headerlink\" title=\"McMillan’s Inequality\"></a>McMillan’s Inequality</h3><p>McMillan’s inequality is necessary for a set of strings to be an alphabet. Suppose $S=\\{s_1,s_2,…,s_k\\}\\subseteq\\Sigma^*$ is an alphabet. For $l_i:=|s_i|$ and $|\\Sigma|=r$ we have,<br>$$<br>\\sum_{1\\leq i\\leq k} r^{-l_i} \\leq 1.<br>$$</p>\n<h4 id=\"proof\"><a href=\"#proof\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>First we took $n$-power and expand the left-hand term, suppose the index of $r$ ranges from $n$ to $nL=n\\max\\{l_i\\}$.<br>$$<br>(\\sum_{1\\leq i\\leq k} r^{-l_i})^n = \\sum_{n\\leq i\\leq nL} a_ir^{-i}.<br>$$<br>where $a_i$ is the number of ways to construct a length $i$ string from $n$ elements of $S$. Since $a_i\\leq r^i$, we have<br>$$<br>(\\sum_{1\\leq i\\leq k} r^{-l_i})^n\\leq n(L-1).<br>$$<br>If the McMillan’s inequality does not hold, as $n\\rightarrow\\infty$, the above inequality will be violated since the left-hand side grows much faster than the right hand side. ${}_\\square$</p>\n"},{"title":"Heirarchy Theorem","date":"2019-02-16T22:32:12.000Z","_content":"\n<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script\n    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>\n</script>\n\nWith more resource comes more power, at least computationally speaking.\n\n### Constructibility\nGiven a function, $f:\\mathbb{N}\\rightarrow\\mathbb{N}$, it is said to be (weakly) time/space construtible if and only if the map $1^n\\mapsto 1^{f(n)}$ could be computed in $O(f(n))$ time/space resources.\n\nIt basically says that $f$ is computationally easier to determine.\n\n### Diagonalization for Undecidability\nOne way to show that there's a problem undecidable is by diagonalization.\nConsider the following language,\n$$\nL=\\{w=\\langle M, x\\rangle: w\\not\\in L(M)\\},\n$$\nwhere M is a Turing machine. If machine $D$ decides $L,$ then\n$$\nw=\\langle D,x\\rangle \\in L\\iff w\\not\\in L(D)=L,\n$$\nwhich is a contradiction. Thus there exists a undecidable problem.\n\n\n### Space Heirachy Theorem\nGiven $s(n)$ weakly space constructible, then there exists a language $A$ that\n- $A\\in SPACE(s(n))$\n- $A\\not\\in SPACE(o(s(n)))$\n\nWe are showing this by also diagonalization. Consider a Turing machine $D$ doing the following,\n- On input $w=\\langle M,10^k\\rangle$ where $M$ is a Turing machine, we try to simulate $M$ on input $w$ under following modification.\n- By space constructibility, calculate $1^{s(n)}$ as memory boundary, if during simulation $M$ attempt to use more then $s(n)$ memory, reject.\n- Maintain a time counter, if simulatation time ever exceeds $2^{s(n)}$, reject.\n- If $M$ accepts $w$, reject; otherwise, accept.\n\nIt is clear from declaration that $L(D)\\in SPACE(s(n)).$ If $L(D)\\in SPACE(o(s(n))),$ then for those machines $M$ running in space $g\\in o(f)$ and large enough $N_0$, $g(n)<s(n)$ whenever $n>N_0.$ Therefore consider $k=N_0,$ $M$ runs to the last step. But then $w\\in L(D)\\iff w\\not\\in L(D),$ which is a contradiction.\n\n#### Remark.\n$SPACE(s(n))\\subseteq TIME(2^{O(s(n))})$, so the third step make sure the total process using no more then $O(s(n))$ memory.\n\n### Time Heirachy Theorem\nGiven $t(n)$ weakly time constructible, then there exists a language $A$ that\n- $A\\in TIME(t(n))$\n- $A\\not\\in TIME(o(t/\\log t))$\n\nThe proof is essentially similar, but note that to avoid zigzag that typically wasting time, we need to drag the time counter and state information along with the pointer location. That would cause $O(log(t))$ time for each transition.\n\n\n","source":"_posts/Heirarchy-Theorem.md","raw":"---\ntitle: Heirarchy Theorem\ndate: 2019-02-16 23:32:12\ntags: complexity\n---\n\n<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script\n    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>\n</script>\n\nWith more resource comes more power, at least computationally speaking.\n\n### Constructibility\nGiven a function, $f:\\mathbb{N}\\rightarrow\\mathbb{N}$, it is said to be (weakly) time/space construtible if and only if the map $1^n\\mapsto 1^{f(n)}$ could be computed in $O(f(n))$ time/space resources.\n\nIt basically says that $f$ is computationally easier to determine.\n\n### Diagonalization for Undecidability\nOne way to show that there's a problem undecidable is by diagonalization.\nConsider the following language,\n$$\nL=\\{w=\\langle M, x\\rangle: w\\not\\in L(M)\\},\n$$\nwhere M is a Turing machine. If machine $D$ decides $L,$ then\n$$\nw=\\langle D,x\\rangle \\in L\\iff w\\not\\in L(D)=L,\n$$\nwhich is a contradiction. Thus there exists a undecidable problem.\n\n\n### Space Heirachy Theorem\nGiven $s(n)$ weakly space constructible, then there exists a language $A$ that\n- $A\\in SPACE(s(n))$\n- $A\\not\\in SPACE(o(s(n)))$\n\nWe are showing this by also diagonalization. Consider a Turing machine $D$ doing the following,\n- On input $w=\\langle M,10^k\\rangle$ where $M$ is a Turing machine, we try to simulate $M$ on input $w$ under following modification.\n- By space constructibility, calculate $1^{s(n)}$ as memory boundary, if during simulation $M$ attempt to use more then $s(n)$ memory, reject.\n- Maintain a time counter, if simulatation time ever exceeds $2^{s(n)}$, reject.\n- If $M$ accepts $w$, reject; otherwise, accept.\n\nIt is clear from declaration that $L(D)\\in SPACE(s(n)).$ If $L(D)\\in SPACE(o(s(n))),$ then for those machines $M$ running in space $g\\in o(f)$ and large enough $N_0$, $g(n)<s(n)$ whenever $n>N_0.$ Therefore consider $k=N_0,$ $M$ runs to the last step. But then $w\\in L(D)\\iff w\\not\\in L(D),$ which is a contradiction.\n\n#### Remark.\n$SPACE(s(n))\\subseteq TIME(2^{O(s(n))})$, so the third step make sure the total process using no more then $O(s(n))$ memory.\n\n### Time Heirachy Theorem\nGiven $t(n)$ weakly time constructible, then there exists a language $A$ that\n- $A\\in TIME(t(n))$\n- $A\\not\\in TIME(o(t/\\log t))$\n\nThe proof is essentially similar, but note that to avoid zigzag that typically wasting time, we need to drag the time counter and state information along with the pointer location. That would cause $O(log(t))$ time for each transition.\n\n\n","slug":"Heirarchy-Theorem","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3moy0002bx4rt99l2vsm","content":"<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML\" async>\n</script>\n\n<p>With more resource comes more power, at least computationally speaking.</p>\n<h3 id=\"Constructibility\"><a href=\"#Constructibility\" class=\"headerlink\" title=\"Constructibility\"></a>Constructibility</h3><p>Given a function, $f:\\mathbb{N}\\rightarrow\\mathbb{N}$, it is said to be (weakly) time/space construtible if and only if the map $1^n\\mapsto 1^{f(n)}$ could be computed in $O(f(n))$ time/space resources.</p>\n<p>It basically says that $f$ is computationally easier to determine.</p>\n<h3 id=\"Diagonalization-for-Undecidability\"><a href=\"#Diagonalization-for-Undecidability\" class=\"headerlink\" title=\"Diagonalization for Undecidability\"></a>Diagonalization for Undecidability</h3><p>One way to show that there’s a problem undecidable is by diagonalization.<br>Consider the following language,<br>$$<br>L=\\{w=\\langle M, x\\rangle: w\\not\\in L(M)\\},<br>$$<br>where M is a Turing machine. If machine $D$ decides $L,$ then<br>$$<br>w=\\langle D,x\\rangle \\in L\\iff w\\not\\in L(D)=L,<br>$$<br>which is a contradiction. Thus there exists a undecidable problem.</p>\n<h3 id=\"Space-Heirachy-Theorem\"><a href=\"#Space-Heirachy-Theorem\" class=\"headerlink\" title=\"Space Heirachy Theorem\"></a>Space Heirachy Theorem</h3><p>Given $s(n)$ weakly space constructible, then there exists a language $A$ that</p>\n<ul>\n<li>$A\\in SPACE(s(n))$</li>\n<li>$A\\not\\in SPACE(o(s(n)))$</li>\n</ul>\n<p>We are showing this by also diagonalization. Consider a Turing machine $D$ doing the following,</p>\n<ul>\n<li>On input $w=\\langle M,10^k\\rangle$ where $M$ is a Turing machine, we try to simulate $M$ on input $w$ under following modification.</li>\n<li>By space constructibility, calculate $1^{s(n)}$ as memory boundary, if during simulation $M$ attempt to use more then $s(n)$ memory, reject.</li>\n<li>Maintain a time counter, if simulatation time ever exceeds $2^{s(n)}$, reject.</li>\n<li>If $M$ accepts $w$, reject; otherwise, accept.</li>\n</ul>\n<p>It is clear from declaration that $L(D)\\in SPACE(s(n)).$ If $L(D)\\in SPACE(o(s(n))),$ then for those machines $M$ running in space $g\\in o(f)$ and large enough $N_0$, $g(n)&lt;s(n)$ whenever $n&gt;N_0.$ Therefore consider $k=N_0,$ $M$ runs to the last step. But then $w\\in L(D)\\iff w\\not\\in L(D),$ which is a contradiction.</p>\n<h4 id=\"Remark\"><a href=\"#Remark\" class=\"headerlink\" title=\"Remark.\"></a>Remark.</h4><p>$SPACE(s(n))\\subseteq TIME(2^{O(s(n))})$, so the third step make sure the total process using no more then $O(s(n))$ memory.</p>\n<h3 id=\"Time-Heirachy-Theorem\"><a href=\"#Time-Heirachy-Theorem\" class=\"headerlink\" title=\"Time Heirachy Theorem\"></a>Time Heirachy Theorem</h3><p>Given $t(n)$ weakly time constructible, then there exists a language $A$ that</p>\n<ul>\n<li>$A\\in TIME(t(n))$</li>\n<li>$A\\not\\in TIME(o(t/\\log t))$</li>\n</ul>\n<p>The proof is essentially similar, but note that to avoid zigzag that typically wasting time, we need to drag the time counter and state information along with the pointer location. That would cause $O(log(t))$ time for each transition.</p>\n","site":{"data":{}},"excerpt":"","more":"<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML\" async>\n</script>\n\n<p>With more resource comes more power, at least computationally speaking.</p>\n<h3 id=\"Constructibility\"><a href=\"#Constructibility\" class=\"headerlink\" title=\"Constructibility\"></a>Constructibility</h3><p>Given a function, $f:\\mathbb{N}\\rightarrow\\mathbb{N}$, it is said to be (weakly) time/space construtible if and only if the map $1^n\\mapsto 1^{f(n)}$ could be computed in $O(f(n))$ time/space resources.</p>\n<p>It basically says that $f$ is computationally easier to determine.</p>\n<h3 id=\"Diagonalization-for-Undecidability\"><a href=\"#Diagonalization-for-Undecidability\" class=\"headerlink\" title=\"Diagonalization for Undecidability\"></a>Diagonalization for Undecidability</h3><p>One way to show that there’s a problem undecidable is by diagonalization.<br>Consider the following language,<br>$$<br>L=\\{w=\\langle M, x\\rangle: w\\not\\in L(M)\\},<br>$$<br>where M is a Turing machine. If machine $D$ decides $L,$ then<br>$$<br>w=\\langle D,x\\rangle \\in L\\iff w\\not\\in L(D)=L,<br>$$<br>which is a contradiction. Thus there exists a undecidable problem.</p>\n<h3 id=\"Space-Heirachy-Theorem\"><a href=\"#Space-Heirachy-Theorem\" class=\"headerlink\" title=\"Space Heirachy Theorem\"></a>Space Heirachy Theorem</h3><p>Given $s(n)$ weakly space constructible, then there exists a language $A$ that</p>\n<ul>\n<li>$A\\in SPACE(s(n))$</li>\n<li>$A\\not\\in SPACE(o(s(n)))$</li>\n</ul>\n<p>We are showing this by also diagonalization. Consider a Turing machine $D$ doing the following,</p>\n<ul>\n<li>On input $w=\\langle M,10^k\\rangle$ where $M$ is a Turing machine, we try to simulate $M$ on input $w$ under following modification.</li>\n<li>By space constructibility, calculate $1^{s(n)}$ as memory boundary, if during simulation $M$ attempt to use more then $s(n)$ memory, reject.</li>\n<li>Maintain a time counter, if simulatation time ever exceeds $2^{s(n)}$, reject.</li>\n<li>If $M$ accepts $w$, reject; otherwise, accept.</li>\n</ul>\n<p>It is clear from declaration that $L(D)\\in SPACE(s(n)).$ If $L(D)\\in SPACE(o(s(n))),$ then for those machines $M$ running in space $g\\in o(f)$ and large enough $N_0$, $g(n)&lt;s(n)$ whenever $n&gt;N_0.$ Therefore consider $k=N_0,$ $M$ runs to the last step. But then $w\\in L(D)\\iff w\\not\\in L(D),$ which is a contradiction.</p>\n<h4 id=\"Remark\"><a href=\"#Remark\" class=\"headerlink\" title=\"Remark.\"></a>Remark.</h4><p>$SPACE(s(n))\\subseteq TIME(2^{O(s(n))})$, so the third step make sure the total process using no more then $O(s(n))$ memory.</p>\n<h3 id=\"Time-Heirachy-Theorem\"><a href=\"#Time-Heirachy-Theorem\" class=\"headerlink\" title=\"Time Heirachy Theorem\"></a>Time Heirachy Theorem</h3><p>Given $t(n)$ weakly time constructible, then there exists a language $A$ that</p>\n<ul>\n<li>$A\\in TIME(t(n))$</li>\n<li>$A\\not\\in TIME(o(t/\\log t))$</li>\n</ul>\n<p>The proof is essentially similar, but note that to avoid zigzag that typically wasting time, we need to drag the time counter and state information along with the pointer location. That would cause $O(log(t))$ time for each transition.</p>\n"},{"title":"ICPC Japan Yokohama 回顧","date":"2018-12-14T21:55:48.000Z","_content":"\n2018年12月，ICPC Japan Yokohama有可能是大學最後一次參加ICPC了(post graduate不知道還會不會參加)，來回顧一下。\n\n### 準備工作\n比賽活動的第一天主要是報到和測試機器，日本區的工作人員很熱情的歡迎我們，和我們介紹流程等等，比較不緊張了一些。\n<img src=\"https://i.imgur.com/5kBAcCI.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/71CaurQ.jpg\" width=\"50%\" height=\"50%\">\n\n\n日本賽區有所謂的「隊伍介紹」，我們很認真地用文字描述了交大和台灣，實際到場才發現許多的隊伍都把隊伍介紹欄位放顏文字或ascii動漫貼圖，相當有趣。現場每個隊伍都有大概一分鐘左右的自我介紹時間，我們很簡短的用兩三句話介紹自己。\n<img src=\"https://i.imgur.com/1ZtCi4C.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/ILOniKq.jpg\" width=\"28%\" height=\"28%\">\n\n\n我們還發現因為日本賽區沒有參考資料限制頁數，所以大部分的人都帶了字典和演算法書。\n\n### 比賽當天\n比賽當天，我們帶著必要的文件，早早出發。\n<img src=\"https://i.imgur.com/u04ML5a.jpg\" width=\"50%\" height=\"50%\">\n\n整體來說，日本賽區的解題狀況是辛苦的([題目](https://icpc.iisf.or.jp/2018-yokohama/judges-commentaries-and-data/?fbclid=IwAR0qeIkV8_y056FIeh57wYJeLdfXPGKexiaHgHHvnWeC_CzXymcZxd5bsxA))，跌了幾個坑分別是：\n- 解A的時候會錯題意花比較久。\n- 把C當成min cost flow，後來還是用了並查集，但其實可以更簡單的完成。\n- G拿最大值建構解而不是拿最小值，當成了DP的問題最後沒解出來，有點可惜。\n\n最後的成績是 rank 29，沒有特別突出但我相信我們已經盡力了。\n<img src=\"https://i.imgur.com/4l1UDKZ.png\" width=\"75%\" height=\"75%\">\n\n賽後有題解，個人覺得這個做法蠻好，能讓解不出來的隊伍也能學到一些東西，這次有兩隊破台，台大拿下了第三名，也恭喜筑波大學拿下 World final的門票，下右圖和筑波大學Aranha老師合影。\n<img src=\"https://i.imgur.com/DC6wmkZ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/5xRT1EP.jpg\" width=\"50%\" height=\"50%\">\n\n晚宴很豐盛，同時也在這裡頒企業獎。\n<img src=\"https://i.imgur.com/ufnO0d4.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/XyoaT5u.jpg\" width=\"50%\" height=\"50%\">\n\n\n\n### 回憶錄\n\n到賽場路上有一個公園，滿漂亮的所以我們合影留念。\n<img src=\"https://i.imgur.com/EkWSKJj.jpg\" width=\"80%\" height=\"80%\">\n\n第三天有企業參訪，但企業參訪內容就不能揭露了，有營業秘密的concern。\n\n日本有許多特色美食，拉麵、燒肉、壽司等等，不勝枚舉直接秀照片啦(另外感謝幫我們拍照的蔡老師)：\n<img src=\"https://i.imgur.com/gkHdNjE.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/exYhAVN.jpg\" width=\"28%\" height=\"28%\">\n<img src=\"https://i.imgur.com/ZoN7sJW.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/9RASjfP.jpg\" width=\"50%\" height=\"50%\">\n<img src=\"https://i.imgur.com/2hwaMjf.png\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/QvIf0bM.png\" width=\"50%\" height=\"50%\">\n<img src=\"https://i.imgur.com/9hAxOSJ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/I7uT2lQ.jpg\" width=\"50%\" height=\"50%\">\n<img src=\"https://i.imgur.com/dU4gG2k.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/slstJhz.jpg\" width=\"50%\" height=\"50%\">\n\n我們還看到了擎空塔、東京鐵塔和一個遊樂園的摩天輪。\n<img src=\"https://i.imgur.com/h6dkYeR.png\" width=\"28%\" height=\"28%\"><img src=\"https://i.imgur.com/osoBVW9.jpg\" width=\"50%\" height=\"50%\">\n<img src=\"https://i.imgur.com/Ta9K8zJ.jpg\" width=\"78%\" height=\"78%\">\n\n\n最後秀個全景擎空塔XD。\n![](https://i.imgur.com/5SQV13c.png)\n\n### Acknowledgement\n特別感謝帶隊的蔡老師，幫我們處理報名、機票和平時訓練的謝老師，還有協助訂飯店最後載我們回新竹的隊友的媽媽。","source":"_posts/ICPC-Japan-Yokohama-回顧.md","raw":"---\ntitle: ICPC Japan Yokohama 回顧\ndate: 2018-12-14 22:55:48\ntags:\n---\n\n2018年12月，ICPC Japan Yokohama有可能是大學最後一次參加ICPC了(post graduate不知道還會不會參加)，來回顧一下。\n\n### 準備工作\n比賽活動的第一天主要是報到和測試機器，日本區的工作人員很熱情的歡迎我們，和我們介紹流程等等，比較不緊張了一些。\n<img src=\"https://i.imgur.com/5kBAcCI.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/71CaurQ.jpg\" width=\"50%\" height=\"50%\">\n\n\n日本賽區有所謂的「隊伍介紹」，我們很認真地用文字描述了交大和台灣，實際到場才發現許多的隊伍都把隊伍介紹欄位放顏文字或ascii動漫貼圖，相當有趣。現場每個隊伍都有大概一分鐘左右的自我介紹時間，我們很簡短的用兩三句話介紹自己。\n<img src=\"https://i.imgur.com/1ZtCi4C.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/ILOniKq.jpg\" width=\"28%\" height=\"28%\">\n\n\n我們還發現因為日本賽區沒有參考資料限制頁數，所以大部分的人都帶了字典和演算法書。\n\n### 比賽當天\n比賽當天，我們帶著必要的文件，早早出發。\n<img src=\"https://i.imgur.com/u04ML5a.jpg\" width=\"50%\" height=\"50%\">\n\n整體來說，日本賽區的解題狀況是辛苦的([題目](https://icpc.iisf.or.jp/2018-yokohama/judges-commentaries-and-data/?fbclid=IwAR0qeIkV8_y056FIeh57wYJeLdfXPGKexiaHgHHvnWeC_CzXymcZxd5bsxA))，跌了幾個坑分別是：\n- 解A的時候會錯題意花比較久。\n- 把C當成min cost flow，後來還是用了並查集，但其實可以更簡單的完成。\n- G拿最大值建構解而不是拿最小值，當成了DP的問題最後沒解出來，有點可惜。\n\n最後的成績是 rank 29，沒有特別突出但我相信我們已經盡力了。\n<img src=\"https://i.imgur.com/4l1UDKZ.png\" width=\"75%\" height=\"75%\">\n\n賽後有題解，個人覺得這個做法蠻好，能讓解不出來的隊伍也能學到一些東西，這次有兩隊破台，台大拿下了第三名，也恭喜筑波大學拿下 World final的門票，下右圖和筑波大學Aranha老師合影。\n<img src=\"https://i.imgur.com/DC6wmkZ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/5xRT1EP.jpg\" width=\"50%\" height=\"50%\">\n\n晚宴很豐盛，同時也在這裡頒企業獎。\n<img src=\"https://i.imgur.com/ufnO0d4.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/XyoaT5u.jpg\" width=\"50%\" height=\"50%\">\n\n\n\n### 回憶錄\n\n到賽場路上有一個公園，滿漂亮的所以我們合影留念。\n<img src=\"https://i.imgur.com/EkWSKJj.jpg\" width=\"80%\" height=\"80%\">\n\n第三天有企業參訪，但企業參訪內容就不能揭露了，有營業秘密的concern。\n\n日本有許多特色美食，拉麵、燒肉、壽司等等，不勝枚舉直接秀照片啦(另外感謝幫我們拍照的蔡老師)：\n<img src=\"https://i.imgur.com/gkHdNjE.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/exYhAVN.jpg\" width=\"28%\" height=\"28%\">\n<img src=\"https://i.imgur.com/ZoN7sJW.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/9RASjfP.jpg\" width=\"50%\" height=\"50%\">\n<img src=\"https://i.imgur.com/2hwaMjf.png\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/QvIf0bM.png\" width=\"50%\" height=\"50%\">\n<img src=\"https://i.imgur.com/9hAxOSJ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/I7uT2lQ.jpg\" width=\"50%\" height=\"50%\">\n<img src=\"https://i.imgur.com/dU4gG2k.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/slstJhz.jpg\" width=\"50%\" height=\"50%\">\n\n我們還看到了擎空塔、東京鐵塔和一個遊樂園的摩天輪。\n<img src=\"https://i.imgur.com/h6dkYeR.png\" width=\"28%\" height=\"28%\"><img src=\"https://i.imgur.com/osoBVW9.jpg\" width=\"50%\" height=\"50%\">\n<img src=\"https://i.imgur.com/Ta9K8zJ.jpg\" width=\"78%\" height=\"78%\">\n\n\n最後秀個全景擎空塔XD。\n![](https://i.imgur.com/5SQV13c.png)\n\n### Acknowledgement\n特別感謝帶隊的蔡老師，幫我們處理報名、機票和平時訓練的謝老師，還有協助訂飯店最後載我們回新竹的隊友的媽媽。","slug":"ICPC-Japan-Yokohama-回顧","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mp00004bx4rglhref28","content":"<p>2018年12月，ICPC Japan Yokohama有可能是大學最後一次參加ICPC了(post graduate不知道還會不會參加)，來回顧一下。</p>\n<h3 id=\"準備工作\"><a href=\"#準備工作\" class=\"headerlink\" title=\"準備工作\"></a>準備工作</h3><p>比賽活動的第一天主要是報到和測試機器，日本區的工作人員很熱情的歡迎我們，和我們介紹流程等等，比較不緊張了一些。<br><img src=\"https://i.imgur.com/5kBAcCI.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/71CaurQ.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>日本賽區有所謂的「隊伍介紹」，我們很認真地用文字描述了交大和台灣，實際到場才發現許多的隊伍都把隊伍介紹欄位放顏文字或ascii動漫貼圖，相當有趣。現場每個隊伍都有大概一分鐘左右的自我介紹時間，我們很簡短的用兩三句話介紹自己。<br><img src=\"https://i.imgur.com/1ZtCi4C.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/ILOniKq.jpg\" width=\"28%\" height=\"28%\"></p>\n<p>我們還發現因為日本賽區沒有參考資料限制頁數，所以大部分的人都帶了字典和演算法書。</p>\n<h3 id=\"比賽當天\"><a href=\"#比賽當天\" class=\"headerlink\" title=\"比賽當天\"></a>比賽當天</h3><p>比賽當天，我們帶著必要的文件，早早出發。<br><img src=\"https://i.imgur.com/u04ML5a.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>整體來說，日本賽區的解題狀況是辛苦的(<a href=\"https://icpc.iisf.or.jp/2018-yokohama/judges-commentaries-and-data/?fbclid=IwAR0qeIkV8_y056FIeh57wYJeLdfXPGKexiaHgHHvnWeC_CzXymcZxd5bsxA\" target=\"_blank\" rel=\"noopener\">題目</a>)，跌了幾個坑分別是：</p>\n<ul>\n<li>解A的時候會錯題意花比較久。</li>\n<li>把C當成min cost flow，後來還是用了並查集，但其實可以更簡單的完成。</li>\n<li>G拿最大值建構解而不是拿最小值，當成了DP的問題最後沒解出來，有點可惜。</li>\n</ul>\n<p>最後的成績是 rank 29，沒有特別突出但我相信我們已經盡力了。<br><img src=\"https://i.imgur.com/4l1UDKZ.png\" width=\"75%\" height=\"75%\"></p>\n<p>賽後有題解，個人覺得這個做法蠻好，能讓解不出來的隊伍也能學到一些東西，這次有兩隊破台，台大拿下了第三名，也恭喜筑波大學拿下 World final的門票，下右圖和筑波大學Aranha老師合影。<br><img src=\"https://i.imgur.com/DC6wmkZ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/5xRT1EP.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>晚宴很豐盛，同時也在這裡頒企業獎。<br><img src=\"https://i.imgur.com/ufnO0d4.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/XyoaT5u.jpg\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"回憶錄\"><a href=\"#回憶錄\" class=\"headerlink\" title=\"回憶錄\"></a>回憶錄</h3><p>到賽場路上有一個公園，滿漂亮的所以我們合影留念。<br><img src=\"https://i.imgur.com/EkWSKJj.jpg\" width=\"80%\" height=\"80%\"></p>\n<p>第三天有企業參訪，但企業參訪內容就不能揭露了，有營業秘密的concern。</p>\n<p>日本有許多特色美食，拉麵、燒肉、壽司等等，不勝枚舉直接秀照片啦(另外感謝幫我們拍照的蔡老師)：<br><img src=\"https://i.imgur.com/gkHdNjE.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/exYhAVN.jpg\" width=\"28%\" height=\"28%\"><br><img src=\"https://i.imgur.com/ZoN7sJW.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/9RASjfP.jpg\" width=\"50%\" height=\"50%\"><br><img src=\"https://i.imgur.com/2hwaMjf.png\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/QvIf0bM.png\" width=\"50%\" height=\"50%\"><br><img src=\"https://i.imgur.com/9hAxOSJ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/I7uT2lQ.jpg\" width=\"50%\" height=\"50%\"><br><img src=\"https://i.imgur.com/dU4gG2k.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/slstJhz.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>我們還看到了擎空塔、東京鐵塔和一個遊樂園的摩天輪。<br><img src=\"https://i.imgur.com/h6dkYeR.png\" width=\"28%\" height=\"28%\"><img src=\"https://i.imgur.com/osoBVW9.jpg\" width=\"50%\" height=\"50%\"><br><img src=\"https://i.imgur.com/Ta9K8zJ.jpg\" width=\"78%\" height=\"78%\"></p>\n<p>最後秀個全景擎空塔XD。<br><img src=\"https://i.imgur.com/5SQV13c.png\" alt=\"\"></p>\n<h3 id=\"Acknowledgement\"><a href=\"#Acknowledgement\" class=\"headerlink\" title=\"Acknowledgement\"></a>Acknowledgement</h3><p>特別感謝帶隊的蔡老師，幫我們處理報名、機票和平時訓練的謝老師，還有協助訂飯店最後載我們回新竹的隊友的媽媽。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2018年12月，ICPC Japan Yokohama有可能是大學最後一次參加ICPC了(post graduate不知道還會不會參加)，來回顧一下。</p>\n<h3 id=\"準備工作\"><a href=\"#準備工作\" class=\"headerlink\" title=\"準備工作\"></a>準備工作</h3><p>比賽活動的第一天主要是報到和測試機器，日本區的工作人員很熱情的歡迎我們，和我們介紹流程等等，比較不緊張了一些。<br><img src=\"https://i.imgur.com/5kBAcCI.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/71CaurQ.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>日本賽區有所謂的「隊伍介紹」，我們很認真地用文字描述了交大和台灣，實際到場才發現許多的隊伍都把隊伍介紹欄位放顏文字或ascii動漫貼圖，相當有趣。現場每個隊伍都有大概一分鐘左右的自我介紹時間，我們很簡短的用兩三句話介紹自己。<br><img src=\"https://i.imgur.com/1ZtCi4C.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/ILOniKq.jpg\" width=\"28%\" height=\"28%\"></p>\n<p>我們還發現因為日本賽區沒有參考資料限制頁數，所以大部分的人都帶了字典和演算法書。</p>\n<h3 id=\"比賽當天\"><a href=\"#比賽當天\" class=\"headerlink\" title=\"比賽當天\"></a>比賽當天</h3><p>比賽當天，我們帶著必要的文件，早早出發。<br><img src=\"https://i.imgur.com/u04ML5a.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>整體來說，日本賽區的解題狀況是辛苦的(<a href=\"https://icpc.iisf.or.jp/2018-yokohama/judges-commentaries-and-data/?fbclid=IwAR0qeIkV8_y056FIeh57wYJeLdfXPGKexiaHgHHvnWeC_CzXymcZxd5bsxA\" target=\"_blank\" rel=\"noopener\">題目</a>)，跌了幾個坑分別是：</p>\n<ul>\n<li>解A的時候會錯題意花比較久。</li>\n<li>把C當成min cost flow，後來還是用了並查集，但其實可以更簡單的完成。</li>\n<li>G拿最大值建構解而不是拿最小值，當成了DP的問題最後沒解出來，有點可惜。</li>\n</ul>\n<p>最後的成績是 rank 29，沒有特別突出但我相信我們已經盡力了。<br><img src=\"https://i.imgur.com/4l1UDKZ.png\" width=\"75%\" height=\"75%\"></p>\n<p>賽後有題解，個人覺得這個做法蠻好，能讓解不出來的隊伍也能學到一些東西，這次有兩隊破台，台大拿下了第三名，也恭喜筑波大學拿下 World final的門票，下右圖和筑波大學Aranha老師合影。<br><img src=\"https://i.imgur.com/DC6wmkZ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/5xRT1EP.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>晚宴很豐盛，同時也在這裡頒企業獎。<br><img src=\"https://i.imgur.com/ufnO0d4.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/XyoaT5u.jpg\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"回憶錄\"><a href=\"#回憶錄\" class=\"headerlink\" title=\"回憶錄\"></a>回憶錄</h3><p>到賽場路上有一個公園，滿漂亮的所以我們合影留念。<br><img src=\"https://i.imgur.com/EkWSKJj.jpg\" width=\"80%\" height=\"80%\"></p>\n<p>第三天有企業參訪，但企業參訪內容就不能揭露了，有營業秘密的concern。</p>\n<p>日本有許多特色美食，拉麵、燒肉、壽司等等，不勝枚舉直接秀照片啦(另外感謝幫我們拍照的蔡老師)：<br><img src=\"https://i.imgur.com/gkHdNjE.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/exYhAVN.jpg\" width=\"28%\" height=\"28%\"><br><img src=\"https://i.imgur.com/ZoN7sJW.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/9RASjfP.jpg\" width=\"50%\" height=\"50%\"><br><img src=\"https://i.imgur.com/2hwaMjf.png\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/QvIf0bM.png\" width=\"50%\" height=\"50%\"><br><img src=\"https://i.imgur.com/9hAxOSJ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/I7uT2lQ.jpg\" width=\"50%\" height=\"50%\"><br><img src=\"https://i.imgur.com/dU4gG2k.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/slstJhz.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>我們還看到了擎空塔、東京鐵塔和一個遊樂園的摩天輪。<br><img src=\"https://i.imgur.com/h6dkYeR.png\" width=\"28%\" height=\"28%\"><img src=\"https://i.imgur.com/osoBVW9.jpg\" width=\"50%\" height=\"50%\"><br><img src=\"https://i.imgur.com/Ta9K8zJ.jpg\" width=\"78%\" height=\"78%\"></p>\n<p>最後秀個全景擎空塔XD。<br><img src=\"https://i.imgur.com/5SQV13c.png\" alt=\"\"></p>\n<h3 id=\"Acknowledgement\"><a href=\"#Acknowledgement\" class=\"headerlink\" title=\"Acknowledgement\"></a>Acknowledgement</h3><p>特別感謝帶隊的蔡老師，幫我們處理報名、機票和平時訓練的謝老師，還有協助訂飯店最後載我們回新竹的隊友的媽媽。</p>\n"},{"title":"Miller-Rabin Primality Test","date":"2019-03-25T17:09:07.000Z","_content":"\nAlthough there's AKS test for primality test, it is usually impractical to use. We will introduce a test proposed by Gary Miller based on Reimann hypothesis then modifed by Michael Rabin into a randomized version that does not rely on such conjecture.\n\n### Theorem [Miller, Rabin]\n$$\nPRIMES\\in coRP\n$$\n\nOn input $n\\in\\mathbb{Z}$,\n- rule out even numbers, and randomly pick $a\\in\\mathbb{Z}_n^\\times$\n- assume $n=r\\cdot 2^k$, $r$ is odd\n- accept if and only if the following holds\n    - $a^r=1$\n    - $\\exists l<k, a^{r\\cdot 2^l}=-1$\n\n### Conversibility of Fermat's little theorem\nIt is a well known fact that for any prime $p$,\n$$\n\\forall a\\in\\mathbb{Z}_p: a^{p-1} = 1.\n$$\n\nIt is natural to ask if converse still hold, i.e. given $n\\in\\mathbb{Z}$ that $\\forall a\\in\\mathbb{Z}_n:a^{n-1}=1$, does it imply that $n$ is prime numbers? If so, it might naturally yield a primality test algorithm. Unfortunately, Carmichael numbers have not only been found but also proven to be infinitely many.\n\nBut since $\\mathbb{Z}_p$ is a finite field, consider the polynomial,\n$$\nf(x) = x^2-1,\n$$\nit contains no more then 2 roots, which is $\\pm 1$. The Miller-Rabin test argues that converse \"almost\" holds.\n\n### Easy Cases\nIf input is prime, from above we have shown that it is accepted, that is also why we have cut out error at one side. If given odd $n\\in\\mathbb{N}$, for $n=p^e$ be prime power, the argument in [previous discussion](https://asd00012334.github.io/2019/03/22/Randomized-Primality-Test/) has shown that it is accepted with probability bounded under $\\frac{1}{2}$.\n\n\n### Proof\nThe algorithm clearly uses polynomial time. Also, it suffices to discuss the case where $n=m_1m_2$ composite. Let $\\phi(n) = r\\cdot 2^k, 2\\nmid r$.\n\nConsider an inclusion tower of subgroups,\n$$\nS_i:= \\{a\\in\\mathbb{Z}_n^\\times : a^{r\\cdot 2^i}=1\\}, i\\leq k\\\\\nS_0\\leq S_1\\leq ...\\leq S_k\\leq S_{k+1}:=\\mathbb{Z}_n^\\times.\n$$\n\nIf this inclusion tower is strict at one place, i.e. for some $c$, $S_{c-1}\\lneq S_c$, then by Lagrange theorem, $|S_{c-1}|\\leq |S_c|/2$. Then by picking the $c$ to be largest one, we'd have\n$$\nPr(\\exists i:a^{r\\cdot 2^i}=-1\\lor a^r=1)\\leq Pr(a\\in S_{c-1})\\leq \\frac{1}{2}.\n$$\n\nSuppose otherwise, $S_0=S_1=...=S_k=\\mathbb{Z}_n^\\times$, then\n$$\n\\forall a\\in\\mathbb{Z}_n^\\times: a^r=1.\n$$\nNote that this case only possibly happens when $n$ is a Carmichael numbers, the Carmichael numbers have been proven to be square free, and we are going to show that it's not possible to even happens.\nAnd by Chinese remainder theorem,\n$$\n\\mathbb{Z}_n\\cong\\mathbb{Z}_{m_1}\\times\\mathbb{Z}_{m_2},\n$$\nchoose $m_1$ to be $p^e$ prime power and co-prime with $m_2$. By the fact that $\\mathbb{Z}_{p^e}=\\langle \\alpha\\rangle$ is cyclic, assume\n$$\na\\mapsto (\\alpha,1),\n$$\ndefined by such ring isomorphism. Then\n$$\na^r\\mapsto(\\alpha^r,1)=(1,1).\n$$\nBut then $r=0\\mod\\phi(p^e)$, which contradict with the fact that $r$ is odd. $_\\Box$\n\n","source":"_posts/Miller-Rabin-Primality-Test.md","raw":"---\ntitle: Miller-Rabin Primality Test\ndate: 2019-03-25 18:09:07\ntags:\n- prime\n- complexity\n---\n\nAlthough there's AKS test for primality test, it is usually impractical to use. We will introduce a test proposed by Gary Miller based on Reimann hypothesis then modifed by Michael Rabin into a randomized version that does not rely on such conjecture.\n\n### Theorem [Miller, Rabin]\n$$\nPRIMES\\in coRP\n$$\n\nOn input $n\\in\\mathbb{Z}$,\n- rule out even numbers, and randomly pick $a\\in\\mathbb{Z}_n^\\times$\n- assume $n=r\\cdot 2^k$, $r$ is odd\n- accept if and only if the following holds\n    - $a^r=1$\n    - $\\exists l<k, a^{r\\cdot 2^l}=-1$\n\n### Conversibility of Fermat's little theorem\nIt is a well known fact that for any prime $p$,\n$$\n\\forall a\\in\\mathbb{Z}_p: a^{p-1} = 1.\n$$\n\nIt is natural to ask if converse still hold, i.e. given $n\\in\\mathbb{Z}$ that $\\forall a\\in\\mathbb{Z}_n:a^{n-1}=1$, does it imply that $n$ is prime numbers? If so, it might naturally yield a primality test algorithm. Unfortunately, Carmichael numbers have not only been found but also proven to be infinitely many.\n\nBut since $\\mathbb{Z}_p$ is a finite field, consider the polynomial,\n$$\nf(x) = x^2-1,\n$$\nit contains no more then 2 roots, which is $\\pm 1$. The Miller-Rabin test argues that converse \"almost\" holds.\n\n### Easy Cases\nIf input is prime, from above we have shown that it is accepted, that is also why we have cut out error at one side. If given odd $n\\in\\mathbb{N}$, for $n=p^e$ be prime power, the argument in [previous discussion](https://asd00012334.github.io/2019/03/22/Randomized-Primality-Test/) has shown that it is accepted with probability bounded under $\\frac{1}{2}$.\n\n\n### Proof\nThe algorithm clearly uses polynomial time. Also, it suffices to discuss the case where $n=m_1m_2$ composite. Let $\\phi(n) = r\\cdot 2^k, 2\\nmid r$.\n\nConsider an inclusion tower of subgroups,\n$$\nS_i:= \\{a\\in\\mathbb{Z}_n^\\times : a^{r\\cdot 2^i}=1\\}, i\\leq k\\\\\nS_0\\leq S_1\\leq ...\\leq S_k\\leq S_{k+1}:=\\mathbb{Z}_n^\\times.\n$$\n\nIf this inclusion tower is strict at one place, i.e. for some $c$, $S_{c-1}\\lneq S_c$, then by Lagrange theorem, $|S_{c-1}|\\leq |S_c|/2$. Then by picking the $c$ to be largest one, we'd have\n$$\nPr(\\exists i:a^{r\\cdot 2^i}=-1\\lor a^r=1)\\leq Pr(a\\in S_{c-1})\\leq \\frac{1}{2}.\n$$\n\nSuppose otherwise, $S_0=S_1=...=S_k=\\mathbb{Z}_n^\\times$, then\n$$\n\\forall a\\in\\mathbb{Z}_n^\\times: a^r=1.\n$$\nNote that this case only possibly happens when $n$ is a Carmichael numbers, the Carmichael numbers have been proven to be square free, and we are going to show that it's not possible to even happens.\nAnd by Chinese remainder theorem,\n$$\n\\mathbb{Z}_n\\cong\\mathbb{Z}_{m_1}\\times\\mathbb{Z}_{m_2},\n$$\nchoose $m_1$ to be $p^e$ prime power and co-prime with $m_2$. By the fact that $\\mathbb{Z}_{p^e}=\\langle \\alpha\\rangle$ is cyclic, assume\n$$\na\\mapsto (\\alpha,1),\n$$\ndefined by such ring isomorphism. Then\n$$\na^r\\mapsto(\\alpha^r,1)=(1,1).\n$$\nBut then $r=0\\mod\\phi(p^e)$, which contradict with the fact that $r$ is odd. $_\\Box$\n\n","slug":"Miller-Rabin-Primality-Test","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mp20007bx4rfjgmtc9h","content":"<p>Although there’s AKS test for primality test, it is usually impractical to use. We will introduce a test proposed by Gary Miller based on Reimann hypothesis then modifed by Michael Rabin into a randomized version that does not rely on such conjecture.</p>\n<h3 id=\"Theorem-Miller-Rabin\"><a href=\"#Theorem-Miller-Rabin\" class=\"headerlink\" title=\"Theorem [Miller, Rabin]\"></a>Theorem [Miller, Rabin]</h3><p>$$<br>PRIMES\\in coRP<br>$$</p>\n<p>On input $n\\in\\mathbb{Z}$,</p>\n<ul>\n<li>rule out even numbers, and randomly pick $a\\in\\mathbb{Z}_n^\\times$</li>\n<li>assume $n=r\\cdot 2^k$, $r$ is odd</li>\n<li>accept if and only if the following holds<ul>\n<li>$a^r=1$</li>\n<li>$\\exists l&lt;k, a^{r\\cdot 2^l}=-1$</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Conversibility-of-Fermat’s-little-theorem\"><a href=\"#Conversibility-of-Fermat’s-little-theorem\" class=\"headerlink\" title=\"Conversibility of Fermat’s little theorem\"></a>Conversibility of Fermat’s little theorem</h3><p>It is a well known fact that for any prime $p$,<br>$$<br>\\forall a\\in\\mathbb{Z}_p: a^{p-1} = 1.<br>$$</p>\n<p>It is natural to ask if converse still hold, i.e. given $n\\in\\mathbb{Z}$ that $\\forall a\\in\\mathbb{Z}_n:a^{n-1}=1$, does it imply that $n$ is prime numbers? If so, it might naturally yield a primality test algorithm. Unfortunately, Carmichael numbers have not only been found but also proven to be infinitely many.</p>\n<p>But since $\\mathbb{Z}_p$ is a finite field, consider the polynomial,<br>$$<br>f(x) = x^2-1,<br>$$<br>it contains no more then 2 roots, which is $\\pm 1$. The Miller-Rabin test argues that converse “almost” holds.</p>\n<h3 id=\"Easy-Cases\"><a href=\"#Easy-Cases\" class=\"headerlink\" title=\"Easy Cases\"></a>Easy Cases</h3><p>If input is prime, from above we have shown that it is accepted, that is also why we have cut out error at one side. If given odd $n\\in\\mathbb{N}$, for $n=p^e$ be prime power, the argument in <a href=\"https://asd00012334.github.io/2019/03/22/Randomized-Primality-Test/\">previous discussion</a> has shown that it is accepted with probability bounded under $\\frac{1}{2}$.</p>\n<h3 id=\"Proof\"><a href=\"#Proof\" class=\"headerlink\" title=\"Proof\"></a>Proof</h3><p>The algorithm clearly uses polynomial time. Also, it suffices to discuss the case where $n=m_1m_2$ composite. Let $\\phi(n) = r\\cdot 2^k, 2\\nmid r$.</p>\n<p>Consider an inclusion tower of subgroups,<br>$$<br>S_i:= \\{a\\in\\mathbb{Z}_n^\\times : a^{r\\cdot 2^i}=1\\}, i\\leq k\\\\<br>S_0\\leq S_1\\leq …\\leq S_k\\leq S_{k+1}:=\\mathbb{Z}_n^\\times.<br>$$</p>\n<p>If this inclusion tower is strict at one place, i.e. for some $c$, $S_{c-1}\\lneq S_c$, then by Lagrange theorem, $|S_{c-1}|\\leq |S_c|/2$. Then by picking the $c$ to be largest one, we’d have<br>$$<br>Pr(\\exists i:a^{r\\cdot 2^i}=-1\\lor a^r=1)\\leq Pr(a\\in S_{c-1})\\leq \\frac{1}{2}.<br>$$</p>\n<p>Suppose otherwise, $S_0=S_1=…=S_k=\\mathbb{Z}_n^\\times$, then<br>$$<br>\\forall a\\in\\mathbb{Z}_n^\\times: a^r=1.<br>$$<br>Note that this case only possibly happens when $n$ is a Carmichael numbers, the Carmichael numbers have been proven to be square free, and we are going to show that it’s not possible to even happens.<br>And by Chinese remainder theorem,<br>$$<br>\\mathbb{Z}_n\\cong\\mathbb{Z}_{m_1}\\times\\mathbb{Z}_{m_2},<br>$$<br>choose $m_1$ to be $p^e$ prime power and co-prime with $m_2$. By the fact that $\\mathbb{Z}_{p^e}=\\langle \\alpha\\rangle$ is cyclic, assume<br>$$<br>a\\mapsto (\\alpha,1),<br>$$<br>defined by such ring isomorphism. Then<br>$$<br>a^r\\mapsto(\\alpha^r,1)=(1,1).<br>$$<br>But then $r=0\\mod\\phi(p^e)$, which contradict with the fact that $r$ is odd. $_\\Box$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Although there’s AKS test for primality test, it is usually impractical to use. We will introduce a test proposed by Gary Miller based on Reimann hypothesis then modifed by Michael Rabin into a randomized version that does not rely on such conjecture.</p>\n<h3 id=\"Theorem-Miller-Rabin\"><a href=\"#Theorem-Miller-Rabin\" class=\"headerlink\" title=\"Theorem [Miller, Rabin]\"></a>Theorem [Miller, Rabin]</h3><p>$$<br>PRIMES\\in coRP<br>$$</p>\n<p>On input $n\\in\\mathbb{Z}$,</p>\n<ul>\n<li>rule out even numbers, and randomly pick $a\\in\\mathbb{Z}_n^\\times$</li>\n<li>assume $n=r\\cdot 2^k$, $r$ is odd</li>\n<li>accept if and only if the following holds<ul>\n<li>$a^r=1$</li>\n<li>$\\exists l&lt;k, a^{r\\cdot 2^l}=-1$</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Conversibility-of-Fermat’s-little-theorem\"><a href=\"#Conversibility-of-Fermat’s-little-theorem\" class=\"headerlink\" title=\"Conversibility of Fermat’s little theorem\"></a>Conversibility of Fermat’s little theorem</h3><p>It is a well known fact that for any prime $p$,<br>$$<br>\\forall a\\in\\mathbb{Z}_p: a^{p-1} = 1.<br>$$</p>\n<p>It is natural to ask if converse still hold, i.e. given $n\\in\\mathbb{Z}$ that $\\forall a\\in\\mathbb{Z}_n:a^{n-1}=1$, does it imply that $n$ is prime numbers? If so, it might naturally yield a primality test algorithm. Unfortunately, Carmichael numbers have not only been found but also proven to be infinitely many.</p>\n<p>But since $\\mathbb{Z}_p$ is a finite field, consider the polynomial,<br>$$<br>f(x) = x^2-1,<br>$$<br>it contains no more then 2 roots, which is $\\pm 1$. The Miller-Rabin test argues that converse “almost” holds.</p>\n<h3 id=\"Easy-Cases\"><a href=\"#Easy-Cases\" class=\"headerlink\" title=\"Easy Cases\"></a>Easy Cases</h3><p>If input is prime, from above we have shown that it is accepted, that is also why we have cut out error at one side. If given odd $n\\in\\mathbb{N}$, for $n=p^e$ be prime power, the argument in <a href=\"https://asd00012334.github.io/2019/03/22/Randomized-Primality-Test/\">previous discussion</a> has shown that it is accepted with probability bounded under $\\frac{1}{2}$.</p>\n<h3 id=\"Proof\"><a href=\"#Proof\" class=\"headerlink\" title=\"Proof\"></a>Proof</h3><p>The algorithm clearly uses polynomial time. Also, it suffices to discuss the case where $n=m_1m_2$ composite. Let $\\phi(n) = r\\cdot 2^k, 2\\nmid r$.</p>\n<p>Consider an inclusion tower of subgroups,<br>$$<br>S_i:= \\{a\\in\\mathbb{Z}_n^\\times : a^{r\\cdot 2^i}=1\\}, i\\leq k\\\\<br>S_0\\leq S_1\\leq …\\leq S_k\\leq S_{k+1}:=\\mathbb{Z}_n^\\times.<br>$$</p>\n<p>If this inclusion tower is strict at one place, i.e. for some $c$, $S_{c-1}\\lneq S_c$, then by Lagrange theorem, $|S_{c-1}|\\leq |S_c|/2$. Then by picking the $c$ to be largest one, we’d have<br>$$<br>Pr(\\exists i:a^{r\\cdot 2^i}=-1\\lor a^r=1)\\leq Pr(a\\in S_{c-1})\\leq \\frac{1}{2}.<br>$$</p>\n<p>Suppose otherwise, $S_0=S_1=…=S_k=\\mathbb{Z}_n^\\times$, then<br>$$<br>\\forall a\\in\\mathbb{Z}_n^\\times: a^r=1.<br>$$<br>Note that this case only possibly happens when $n$ is a Carmichael numbers, the Carmichael numbers have been proven to be square free, and we are going to show that it’s not possible to even happens.<br>And by Chinese remainder theorem,<br>$$<br>\\mathbb{Z}_n\\cong\\mathbb{Z}_{m_1}\\times\\mathbb{Z}_{m_2},<br>$$<br>choose $m_1$ to be $p^e$ prime power and co-prime with $m_2$. By the fact that $\\mathbb{Z}_{p^e}=\\langle \\alpha\\rangle$ is cyclic, assume<br>$$<br>a\\mapsto (\\alpha,1),<br>$$<br>defined by such ring isomorphism. Then<br>$$<br>a^r\\mapsto(\\alpha^r,1)=(1,1).<br>$$<br>But then $r=0\\mod\\phi(p^e)$, which contradict with the fact that $r$ is odd. $_\\Box$</p>\n"},{"title":"On the Communication Complexity of EQ","date":"2019-05-18T01:27:34.000Z","_content":"\nThe notion of communication complexity is to look only at number of information that is being exchanged between multiple parties.\n## Deterministic Communication\n\n### Def. Communication Complexity\nA (communication) protocol $P$ is a rooted binary tree, with each internal node $v$ labelled with a boolean function,\n$$\nf_v: \\{0,1\\}^n\\rightarrow\\{0,1\\}\n$$\n\nOn input $(x,y)$, the computation start from the root. At each internal node, either Alice or Bob sendss one bit. When Alice is speaking, $f_v(x)$ is sent, otherwise, $f_v(y)$ is sent. If $0$ is yield, the protocol go to the left child, otherwise, it goes to the right child. Each leaf node is labelled with output functions,\n$$\nf_v: \\{0,1\\}^n\\times\\{0,1\\}^n\\rightarrow\\{0,1\\},\n$$\nthen output $f(x,y)$. In our setting, we require Alice and Bob to make consensus on their outputs, if not, then whoever knows the output first could send out one output bit, so both would agree on the same output, that would only require one more bit.\n\nWe said the depth of $P$ is the depth of underlying tree. And (communication) complexity of a function $f:\\{0,1\\}^n\\times\\{0,1\\}^n$ be the smallest depth over all possible $P$. For deterministic one, we denote $D^{cc}(f)$.\n\n### Cor. $D^{cc}(f)\\leq n+1$\n\nSimply send all bits at once from Alice to Bob, then send output bits from Bob.\n\n### Def. Combinatorial Rectangle\n\nA (combinatorial) rectangle is a set $A\\times B$ where\n$$\nA, B\\subseteq \\{0,1\\}^n.\n$$\n\nWe care about combinatorial rectangle because it captures the state of communication. Namely, we have the following.\n\n### Lem.\n\nGiven protocol $P$, node $v$. define $I_v:=\\{(x,y):P$ on $(x,y)$ goes through node $v\\}$. Then $I_v$ is a rectangle.\n\n#### proof.\n\nLet's inductively suppose $v$ is a $b$-child of $u$ where $I_u=A\\times B$ is a rectangle. Then $I_v=(A\\cap f^{-1}[b])\\times B$, which is obviously a rectangle. $_\\Box$\n\nFurthermore, because each $I_v$'s at leaves are necessarily disjoint, we can partitioned all possible inputs into rectangles.\n\n### Cor.\nSuppose $P$ is a $c$-bit protocol for $f$, then $\\{0,1\\}^n\\times \\{0,1\\}^n$ could be partitioned into $2^c$ $f$-monochromatic rectangles.\n\n\n### Def.\nA $b$-fooling set $S\\subseteq\\{0,1\\}^n\\times\\{0,1\\}^n$ for $f$ is a $b$-monochromatic subset that contains no $b$-monochromatic rectangles of size larger than 1. Equivalently,\n$$\n\\forall (x,y)\\in S: f(x,y)=b,\\\\\n\\forall (x,y),(x',y')\\in S: f(x,y')\\neq b\\lor f(x',y)\\neq b.\n$$\n\n### Cor.\nLet $S$ be a $b$-fooling set for $f$, then $D^{cc}(f)\\geq \\lg|S|$.\n\n#### proof.\nIt is because $S$ could collect no more than one ellement from each $f$-monochromatic rectangle, and we could partitioned all possible input into no more than $2^c$ monochromatic rectangle, where $c$ is the depth of $P$. Therefore, we have $2^c\\geq |S|$. $_\\Box$\n\nThe corollary gives a complexity lower bound with respect to size of a fooling set. Techniques using this to provide communication lower bounds are called the *fooling set methods*. For example, let's consider the equality problem,\n$$\nEQ_n = \\{(x,y)\\in\\{0,1\\}^n\\times\\{0,1\\}^n:x=y\\}.\n$$\nPicking $EQ_n$ itself as the $1$-fooling set,\n$$\nD^{cc}(EQ_n)\\geq n.\n$$\nBy looking closer, the lower bound $n$ only contains the $1$-monochromatic rectangles. If we look closer, there must be at least one $0$-monochromatic rectangle contained in the communication matrix. We therefore have the folloing lower bound.\n### Prop.\n$$\nD^{cc}(EQ_n)\\geq n+1.\n$$\n\n## Non-deterministic Communication\nWhen walking on the communication tree, we non-deterministically take our step by descending to possibly both childs. We output 1 if one bracnch output 1, otherwise output 0. Equivalently. the notion of non-deterministic communication could also be introduced in the \"verifier-certificate\" manner. Which is the existence of verifier functions $V_a,V_b:\\{0,1\\}^n\\times \\{0,1\\}^k\\rightarrow \\{0,1\\}$ for both Alice and Bob where,\n$$\nx\\in L\\Rightarrow \\exists z\\in\\{0,1\\}^k:V_a(x,z)=1\\land V_b(y,z)=1,\\\\\nx\\not\\in L\\Rightarrow\\forall z\\in\\{0,1\\}^k:V_a(x,z)=0\\lor V_b(y,z)=0.\n$$\nThe smallest possible $k$ is the non-deterministic communication complexity, denoted $N_1(f)$. Similarly, we could define the co-non-deterministic communication and $N_0(f)$.\n\nIt follows immediately that, if we choose $0$-certificate as the index of bit pointing to where $x,y$ differ (if there is), then the following upper bound holds.\n\n### Cor.\n$$\nN_0(EQ_n)\\leq\\lceil\\lg n\\rceil.\n$$\n\n### Def.\nFor $f:\\{0,1\\}^n\\times\\{0,1\\}^n\\rightarrow\\{0,1\\}$, the $b$-cover number $C_b(f)$ is defined as the minium number of $b$-monochromatic rectangles $A_i\\times B_i$ that $f(x,y) = \\bigvee_{i}[x\\in A_i\\land y\\in B_i]$.\n\n\n### Lem.\n$$\nN_b(f)=\\lceil\\lg C_b(f)\\rceil.\n$$\n\n#### proof.\nFor $N_b(f)\\leq\\lceil\\lg C_b(f)\\rceil$ part, simply choose $b$-certificate be an index pointing to a $b$-monochromatic rectangle. For $N_b(f)\\geq\\lceil\\lg C_b(f)\\rceil$ part, we know that each $b$-certificate $z$ would yield a rectanglel, namely,\n$$\n\\{V_a(x,z)=b\\}\\times\\{V_b(y,z)=b\\}.\n$$\nThese rectangles cover the whole $b$-colorred inputs. Therefore we have,\n$$\n2^{N_b(f)}\\geq C_b(f).\n$$\n$_\\Box$\n\nBy the similar argument as above, because there is a $1$-fooling set as large as $2^n$ and some $0$-rectangles in $EQ_n$. We have $C_b(EQ_n)\\geq 2^n+1$, therefore we have the following lower bound.\n### Cor.\n$$\nN_1(EQ_n)\\geq n+1.\n$$\n\n## Randomized Communication\nThe randomized communication is essentially similar as the previous definition. Except each step here could be performed randomly. We are going to show a protocol that solves $EQ_n$ in $O(\\lg n)$ number of bits.\n\n### Cor.\nThere exists a $coRP$ communication protocol that resolve $EQ_n$\n#### proof.\nConsider the following protocol.\n\nOn input $x,y$, first we could compute\n$$\np_x(z)=\\sum_{1\\leq i\\leq n}x_iz^i,\\\\\np_y(z)=\\sum_{1\\leq i\\leq n}y_iz^i.\n$$\nRandomly pick $r\\in\\mathbb{F}$, accept if $p_x(r)=p_y(r)$, otherwise reject.\nSince a polynomial can only have degree number of roots, by picking $\\mathbb{F}$ to be at least $2$ times larger than $n\\geq\\deg[p_x(z)-p_y(z)]$, we are guaranteed to obtain a $coRP$ protocol, since if $x=y$, the protocol certainly accept, otherwise,\n$$\nPr_r[p_x(r)=p_y(r)]\\leq \\frac{\\deg(p_x-p_y)}{|\\mathbb{F}|}\\leq\\frac{1}{2}.\n$$\n$_\\Box$\n\n## Complexity Classes\nWe sum up with relations between communication complexity classes.\n### Def.\n- $P^{cc}=\\{f:D^{cc}(f)\\leq poly(\\lg n)\\}$\n- $NP^{cc}=\\{f:N_1^{cc}(f)\\leq poly(\\lg n)\\}$\n- $coNP^{cc}=\\{f:N_0^{cc}(f)\\leq poly(\\lg n)\\}$\n- $RP^{cc}=\\{f:\\exists$ RP protocol with complexity $\\leq poly(\\lg n)\\}$\n- $coRP^{cc}=\\{f:\\exists$ coRP protocol with complexity $\\leq poly(\\lg n)\\}$\n\n### Theorems\nFrom above arguement, we conclude the following relations.\n- $P^{cc}\\subsetneq RP^{cc}\\subseteq NP^{cc}$\n- $P^{cc}\\subsetneq coRP^{cc}\\subseteq coNP^{cc}$\n- $NP^{cc}\\neq coNP^{cc}$\n- $NP^{cc}\\not\\supseteq coRP^{cc}$\n- $coNP^{cc}\\not\\supseteq RP^{cc}$\n\n\n","source":"_posts/On-the-Communication-Complexity-of-EQ.md","raw":"---\ntitle: On the Communication Complexity of EQ\ndate: 2019-05-18 03:27:34\ntags:\n- complexity\n- communication\n---\n\nThe notion of communication complexity is to look only at number of information that is being exchanged between multiple parties.\n## Deterministic Communication\n\n### Def. Communication Complexity\nA (communication) protocol $P$ is a rooted binary tree, with each internal node $v$ labelled with a boolean function,\n$$\nf_v: \\{0,1\\}^n\\rightarrow\\{0,1\\}\n$$\n\nOn input $(x,y)$, the computation start from the root. At each internal node, either Alice or Bob sendss one bit. When Alice is speaking, $f_v(x)$ is sent, otherwise, $f_v(y)$ is sent. If $0$ is yield, the protocol go to the left child, otherwise, it goes to the right child. Each leaf node is labelled with output functions,\n$$\nf_v: \\{0,1\\}^n\\times\\{0,1\\}^n\\rightarrow\\{0,1\\},\n$$\nthen output $f(x,y)$. In our setting, we require Alice and Bob to make consensus on their outputs, if not, then whoever knows the output first could send out one output bit, so both would agree on the same output, that would only require one more bit.\n\nWe said the depth of $P$ is the depth of underlying tree. And (communication) complexity of a function $f:\\{0,1\\}^n\\times\\{0,1\\}^n$ be the smallest depth over all possible $P$. For deterministic one, we denote $D^{cc}(f)$.\n\n### Cor. $D^{cc}(f)\\leq n+1$\n\nSimply send all bits at once from Alice to Bob, then send output bits from Bob.\n\n### Def. Combinatorial Rectangle\n\nA (combinatorial) rectangle is a set $A\\times B$ where\n$$\nA, B\\subseteq \\{0,1\\}^n.\n$$\n\nWe care about combinatorial rectangle because it captures the state of communication. Namely, we have the following.\n\n### Lem.\n\nGiven protocol $P$, node $v$. define $I_v:=\\{(x,y):P$ on $(x,y)$ goes through node $v\\}$. Then $I_v$ is a rectangle.\n\n#### proof.\n\nLet's inductively suppose $v$ is a $b$-child of $u$ where $I_u=A\\times B$ is a rectangle. Then $I_v=(A\\cap f^{-1}[b])\\times B$, which is obviously a rectangle. $_\\Box$\n\nFurthermore, because each $I_v$'s at leaves are necessarily disjoint, we can partitioned all possible inputs into rectangles.\n\n### Cor.\nSuppose $P$ is a $c$-bit protocol for $f$, then $\\{0,1\\}^n\\times \\{0,1\\}^n$ could be partitioned into $2^c$ $f$-monochromatic rectangles.\n\n\n### Def.\nA $b$-fooling set $S\\subseteq\\{0,1\\}^n\\times\\{0,1\\}^n$ for $f$ is a $b$-monochromatic subset that contains no $b$-monochromatic rectangles of size larger than 1. Equivalently,\n$$\n\\forall (x,y)\\in S: f(x,y)=b,\\\\\n\\forall (x,y),(x',y')\\in S: f(x,y')\\neq b\\lor f(x',y)\\neq b.\n$$\n\n### Cor.\nLet $S$ be a $b$-fooling set for $f$, then $D^{cc}(f)\\geq \\lg|S|$.\n\n#### proof.\nIt is because $S$ could collect no more than one ellement from each $f$-monochromatic rectangle, and we could partitioned all possible input into no more than $2^c$ monochromatic rectangle, where $c$ is the depth of $P$. Therefore, we have $2^c\\geq |S|$. $_\\Box$\n\nThe corollary gives a complexity lower bound with respect to size of a fooling set. Techniques using this to provide communication lower bounds are called the *fooling set methods*. For example, let's consider the equality problem,\n$$\nEQ_n = \\{(x,y)\\in\\{0,1\\}^n\\times\\{0,1\\}^n:x=y\\}.\n$$\nPicking $EQ_n$ itself as the $1$-fooling set,\n$$\nD^{cc}(EQ_n)\\geq n.\n$$\nBy looking closer, the lower bound $n$ only contains the $1$-monochromatic rectangles. If we look closer, there must be at least one $0$-monochromatic rectangle contained in the communication matrix. We therefore have the folloing lower bound.\n### Prop.\n$$\nD^{cc}(EQ_n)\\geq n+1.\n$$\n\n## Non-deterministic Communication\nWhen walking on the communication tree, we non-deterministically take our step by descending to possibly both childs. We output 1 if one bracnch output 1, otherwise output 0. Equivalently. the notion of non-deterministic communication could also be introduced in the \"verifier-certificate\" manner. Which is the existence of verifier functions $V_a,V_b:\\{0,1\\}^n\\times \\{0,1\\}^k\\rightarrow \\{0,1\\}$ for both Alice and Bob where,\n$$\nx\\in L\\Rightarrow \\exists z\\in\\{0,1\\}^k:V_a(x,z)=1\\land V_b(y,z)=1,\\\\\nx\\not\\in L\\Rightarrow\\forall z\\in\\{0,1\\}^k:V_a(x,z)=0\\lor V_b(y,z)=0.\n$$\nThe smallest possible $k$ is the non-deterministic communication complexity, denoted $N_1(f)$. Similarly, we could define the co-non-deterministic communication and $N_0(f)$.\n\nIt follows immediately that, if we choose $0$-certificate as the index of bit pointing to where $x,y$ differ (if there is), then the following upper bound holds.\n\n### Cor.\n$$\nN_0(EQ_n)\\leq\\lceil\\lg n\\rceil.\n$$\n\n### Def.\nFor $f:\\{0,1\\}^n\\times\\{0,1\\}^n\\rightarrow\\{0,1\\}$, the $b$-cover number $C_b(f)$ is defined as the minium number of $b$-monochromatic rectangles $A_i\\times B_i$ that $f(x,y) = \\bigvee_{i}[x\\in A_i\\land y\\in B_i]$.\n\n\n### Lem.\n$$\nN_b(f)=\\lceil\\lg C_b(f)\\rceil.\n$$\n\n#### proof.\nFor $N_b(f)\\leq\\lceil\\lg C_b(f)\\rceil$ part, simply choose $b$-certificate be an index pointing to a $b$-monochromatic rectangle. For $N_b(f)\\geq\\lceil\\lg C_b(f)\\rceil$ part, we know that each $b$-certificate $z$ would yield a rectanglel, namely,\n$$\n\\{V_a(x,z)=b\\}\\times\\{V_b(y,z)=b\\}.\n$$\nThese rectangles cover the whole $b$-colorred inputs. Therefore we have,\n$$\n2^{N_b(f)}\\geq C_b(f).\n$$\n$_\\Box$\n\nBy the similar argument as above, because there is a $1$-fooling set as large as $2^n$ and some $0$-rectangles in $EQ_n$. We have $C_b(EQ_n)\\geq 2^n+1$, therefore we have the following lower bound.\n### Cor.\n$$\nN_1(EQ_n)\\geq n+1.\n$$\n\n## Randomized Communication\nThe randomized communication is essentially similar as the previous definition. Except each step here could be performed randomly. We are going to show a protocol that solves $EQ_n$ in $O(\\lg n)$ number of bits.\n\n### Cor.\nThere exists a $coRP$ communication protocol that resolve $EQ_n$\n#### proof.\nConsider the following protocol.\n\nOn input $x,y$, first we could compute\n$$\np_x(z)=\\sum_{1\\leq i\\leq n}x_iz^i,\\\\\np_y(z)=\\sum_{1\\leq i\\leq n}y_iz^i.\n$$\nRandomly pick $r\\in\\mathbb{F}$, accept if $p_x(r)=p_y(r)$, otherwise reject.\nSince a polynomial can only have degree number of roots, by picking $\\mathbb{F}$ to be at least $2$ times larger than $n\\geq\\deg[p_x(z)-p_y(z)]$, we are guaranteed to obtain a $coRP$ protocol, since if $x=y$, the protocol certainly accept, otherwise,\n$$\nPr_r[p_x(r)=p_y(r)]\\leq \\frac{\\deg(p_x-p_y)}{|\\mathbb{F}|}\\leq\\frac{1}{2}.\n$$\n$_\\Box$\n\n## Complexity Classes\nWe sum up with relations between communication complexity classes.\n### Def.\n- $P^{cc}=\\{f:D^{cc}(f)\\leq poly(\\lg n)\\}$\n- $NP^{cc}=\\{f:N_1^{cc}(f)\\leq poly(\\lg n)\\}$\n- $coNP^{cc}=\\{f:N_0^{cc}(f)\\leq poly(\\lg n)\\}$\n- $RP^{cc}=\\{f:\\exists$ RP protocol with complexity $\\leq poly(\\lg n)\\}$\n- $coRP^{cc}=\\{f:\\exists$ coRP protocol with complexity $\\leq poly(\\lg n)\\}$\n\n### Theorems\nFrom above arguement, we conclude the following relations.\n- $P^{cc}\\subsetneq RP^{cc}\\subseteq NP^{cc}$\n- $P^{cc}\\subsetneq coRP^{cc}\\subseteq coNP^{cc}$\n- $NP^{cc}\\neq coNP^{cc}$\n- $NP^{cc}\\not\\supseteq coRP^{cc}$\n- $coNP^{cc}\\not\\supseteq RP^{cc}$\n\n\n","slug":"On-the-Communication-Complexity-of-EQ","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mp30008bx4ryawoaqb1","content":"<p>The notion of communication complexity is to look only at number of information that is being exchanged between multiple parties.</p>\n<h2 id=\"Deterministic-Communication\"><a href=\"#Deterministic-Communication\" class=\"headerlink\" title=\"Deterministic Communication\"></a>Deterministic Communication</h2><h3 id=\"Def-Communication-Complexity\"><a href=\"#Def-Communication-Complexity\" class=\"headerlink\" title=\"Def. Communication Complexity\"></a>Def. Communication Complexity</h3><p>A (communication) protocol $P$ is a rooted binary tree, with each internal node $v$ labelled with a boolean function,<br>$$<br>f_v: \\{0,1\\}^n\\rightarrow\\{0,1\\}<br>$$</p>\n<p>On input $(x,y)$, the computation start from the root. At each internal node, either Alice or Bob sendss one bit. When Alice is speaking, $f_v(x)$ is sent, otherwise, $f_v(y)$ is sent. If $0$ is yield, the protocol go to the left child, otherwise, it goes to the right child. Each leaf node is labelled with output functions,<br>$$<br>f_v: \\{0,1\\}^n\\times\\{0,1\\}^n\\rightarrow\\{0,1\\},<br>$$<br>then output $f(x,y)$. In our setting, we require Alice and Bob to make consensus on their outputs, if not, then whoever knows the output first could send out one output bit, so both would agree on the same output, that would only require one more bit.</p>\n<p>We said the depth of $P$ is the depth of underlying tree. And (communication) complexity of a function $f:\\{0,1\\}^n\\times\\{0,1\\}^n$ be the smallest depth over all possible $P$. For deterministic one, we denote $D^{cc}(f)$.</p>\n<h3 id=\"Cor-D-cc-f-leq-n-1\"><a href=\"#Cor-D-cc-f-leq-n-1\" class=\"headerlink\" title=\"Cor. $D^{cc}(f)\\leq n+1$\"></a>Cor. $D^{cc}(f)\\leq n+1$</h3><p>Simply send all bits at once from Alice to Bob, then send output bits from Bob.</p>\n<h3 id=\"Def-Combinatorial-Rectangle\"><a href=\"#Def-Combinatorial-Rectangle\" class=\"headerlink\" title=\"Def. Combinatorial Rectangle\"></a>Def. Combinatorial Rectangle</h3><p>A (combinatorial) rectangle is a set $A\\times B$ where<br>$$<br>A, B\\subseteq \\{0,1\\}^n.<br>$$</p>\n<p>We care about combinatorial rectangle because it captures the state of communication. Namely, we have the following.</p>\n<h3 id=\"Lem\"><a href=\"#Lem\" class=\"headerlink\" title=\"Lem.\"></a>Lem.</h3><p>Given protocol $P$, node $v$. define $I_v:=\\{(x,y):P$ on $(x,y)$ goes through node $v\\}$. Then $I_v$ is a rectangle.</p>\n<h4 id=\"proof\"><a href=\"#proof\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>Let’s inductively suppose $v$ is a $b$-child of $u$ where $I_u=A\\times B$ is a rectangle. Then $I_v=(A\\cap f^{-1}[b])\\times B$, which is obviously a rectangle. $_\\Box$</p>\n<p>Furthermore, because each $I_v$’s at leaves are necessarily disjoint, we can partitioned all possible inputs into rectangles.</p>\n<h3 id=\"Cor\"><a href=\"#Cor\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>Suppose $P$ is a $c$-bit protocol for $f$, then $\\{0,1\\}^n\\times \\{0,1\\}^n$ could be partitioned into $2^c$ $f$-monochromatic rectangles.</p>\n<h3 id=\"Def\"><a href=\"#Def\" class=\"headerlink\" title=\"Def.\"></a>Def.</h3><p>A $b$-fooling set $S\\subseteq\\{0,1\\}^n\\times\\{0,1\\}^n$ for $f$ is a $b$-monochromatic subset that contains no $b$-monochromatic rectangles of size larger than 1. Equivalently,<br>$$<br>\\forall (x,y)\\in S: f(x,y)=b,\\\\<br>\\forall (x,y),(x’,y’)\\in S: f(x,y’)\\neq b\\lor f(x’,y)\\neq b.<br>$$</p>\n<h3 id=\"Cor-1\"><a href=\"#Cor-1\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>Let $S$ be a $b$-fooling set for $f$, then $D^{cc}(f)\\geq \\lg|S|$.</p>\n<h4 id=\"proof-1\"><a href=\"#proof-1\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>It is because $S$ could collect no more than one ellement from each $f$-monochromatic rectangle, and we could partitioned all possible input into no more than $2^c$ monochromatic rectangle, where $c$ is the depth of $P$. Therefore, we have $2^c\\geq |S|$. $_\\Box$</p>\n<p>The corollary gives a complexity lower bound with respect to size of a fooling set. Techniques using this to provide communication lower bounds are called the <em>fooling set methods</em>. For example, let’s consider the equality problem,<br>$$<br>EQ_n = \\{(x,y)\\in\\{0,1\\}^n\\times\\{0,1\\}^n:x=y\\}.<br>$$<br>Picking $EQ_n$ itself as the $1$-fooling set,<br>$$<br>D^{cc}(EQ_n)\\geq n.<br>$$<br>By looking closer, the lower bound $n$ only contains the $1$-monochromatic rectangles. If we look closer, there must be at least one $0$-monochromatic rectangle contained in the communication matrix. We therefore have the folloing lower bound.</p>\n<h3 id=\"Prop\"><a href=\"#Prop\" class=\"headerlink\" title=\"Prop.\"></a>Prop.</h3><p>$$<br>D^{cc}(EQ_n)\\geq n+1.<br>$$</p>\n<h2 id=\"Non-deterministic-Communication\"><a href=\"#Non-deterministic-Communication\" class=\"headerlink\" title=\"Non-deterministic Communication\"></a>Non-deterministic Communication</h2><p>When walking on the communication tree, we non-deterministically take our step by descending to possibly both childs. We output 1 if one bracnch output 1, otherwise output 0. Equivalently. the notion of non-deterministic communication could also be introduced in the “verifier-certificate” manner. Which is the existence of verifier functions $V_a,V_b:\\{0,1\\}^n\\times \\{0,1\\}^k\\rightarrow \\{0,1\\}$ for both Alice and Bob where,<br>$$<br>x\\in L\\Rightarrow \\exists z\\in\\{0,1\\}^k:V_a(x,z)=1\\land V_b(y,z)=1,\\\\<br>x\\not\\in L\\Rightarrow\\forall z\\in\\{0,1\\}^k:V_a(x,z)=0\\lor V_b(y,z)=0.<br>$$<br>The smallest possible $k$ is the non-deterministic communication complexity, denoted $N_1(f)$. Similarly, we could define the co-non-deterministic communication and $N_0(f)$.</p>\n<p>It follows immediately that, if we choose $0$-certificate as the index of bit pointing to where $x,y$ differ (if there is), then the following upper bound holds.</p>\n<h3 id=\"Cor-2\"><a href=\"#Cor-2\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>$$<br>N_0(EQ_n)\\leq\\lceil\\lg n\\rceil.<br>$$</p>\n<h3 id=\"Def-1\"><a href=\"#Def-1\" class=\"headerlink\" title=\"Def.\"></a>Def.</h3><p>For $f:\\{0,1\\}^n\\times\\{0,1\\}^n\\rightarrow\\{0,1\\}$, the $b$-cover number $C_b(f)$ is defined as the minium number of $b$-monochromatic rectangles $A_i\\times B_i$ that $f(x,y) = \\bigvee_{i}[x\\in A_i\\land y\\in B_i]$.</p>\n<h3 id=\"Lem-1\"><a href=\"#Lem-1\" class=\"headerlink\" title=\"Lem.\"></a>Lem.</h3><p>$$<br>N_b(f)=\\lceil\\lg C_b(f)\\rceil.<br>$$</p>\n<h4 id=\"proof-2\"><a href=\"#proof-2\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>For $N_b(f)\\leq\\lceil\\lg C_b(f)\\rceil$ part, simply choose $b$-certificate be an index pointing to a $b$-monochromatic rectangle. For $N_b(f)\\geq\\lceil\\lg C_b(f)\\rceil$ part, we know that each $b$-certificate $z$ would yield a rectanglel, namely,<br>$$<br>\\{V_a(x,z)=b\\}\\times\\{V_b(y,z)=b\\}.<br>$$<br>These rectangles cover the whole $b$-colorred inputs. Therefore we have,<br>$$<br>2^{N_b(f)}\\geq C_b(f).<br>$$<br>$_\\Box$</p>\n<p>By the similar argument as above, because there is a $1$-fooling set as large as $2^n$ and some $0$-rectangles in $EQ_n$. We have $C_b(EQ_n)\\geq 2^n+1$, therefore we have the following lower bound.</p>\n<h3 id=\"Cor-3\"><a href=\"#Cor-3\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>$$<br>N_1(EQ_n)\\geq n+1.<br>$$</p>\n<h2 id=\"Randomized-Communication\"><a href=\"#Randomized-Communication\" class=\"headerlink\" title=\"Randomized Communication\"></a>Randomized Communication</h2><p>The randomized communication is essentially similar as the previous definition. Except each step here could be performed randomly. We are going to show a protocol that solves $EQ_n$ in $O(\\lg n)$ number of bits.</p>\n<h3 id=\"Cor-4\"><a href=\"#Cor-4\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>There exists a $coRP$ communication protocol that resolve $EQ_n$</p>\n<h4 id=\"proof-3\"><a href=\"#proof-3\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>Consider the following protocol.</p>\n<p>On input $x,y$, first we could compute<br>$$<br>p_x(z)=\\sum_{1\\leq i\\leq n}x_iz^i,\\\\<br>p_y(z)=\\sum_{1\\leq i\\leq n}y_iz^i.<br>$$<br>Randomly pick $r\\in\\mathbb{F}$, accept if $p_x(r)=p_y(r)$, otherwise reject.<br>Since a polynomial can only have degree number of roots, by picking $\\mathbb{F}$ to be at least $2$ times larger than $n\\geq\\deg[p_x(z)-p_y(z)]$, we are guaranteed to obtain a $coRP$ protocol, since if $x=y$, the protocol certainly accept, otherwise,<br>$$<br>Pr_r[p_x(r)=p_y(r)]\\leq \\frac{\\deg(p_x-p_y)}{|\\mathbb{F}|}\\leq\\frac{1}{2}.<br>$$<br>$_\\Box$</p>\n<h2 id=\"Complexity-Classes\"><a href=\"#Complexity-Classes\" class=\"headerlink\" title=\"Complexity Classes\"></a>Complexity Classes</h2><p>We sum up with relations between communication complexity classes.</p>\n<h3 id=\"Def-2\"><a href=\"#Def-2\" class=\"headerlink\" title=\"Def.\"></a>Def.</h3><ul>\n<li>$P^{cc}=\\{f:D^{cc}(f)\\leq poly(\\lg n)\\}$</li>\n<li>$NP^{cc}=\\{f:N_1^{cc}(f)\\leq poly(\\lg n)\\}$</li>\n<li>$coNP^{cc}=\\{f:N_0^{cc}(f)\\leq poly(\\lg n)\\}$</li>\n<li>$RP^{cc}=\\{f:\\exists$ RP protocol with complexity $\\leq poly(\\lg n)\\}$</li>\n<li>$coRP^{cc}=\\{f:\\exists$ coRP protocol with complexity $\\leq poly(\\lg n)\\}$</li>\n</ul>\n<h3 id=\"Theorems\"><a href=\"#Theorems\" class=\"headerlink\" title=\"Theorems\"></a>Theorems</h3><p>From above arguement, we conclude the following relations.</p>\n<ul>\n<li>$P^{cc}\\subsetneq RP^{cc}\\subseteq NP^{cc}$</li>\n<li>$P^{cc}\\subsetneq coRP^{cc}\\subseteq coNP^{cc}$</li>\n<li>$NP^{cc}\\neq coNP^{cc}$</li>\n<li>$NP^{cc}\\not\\supseteq coRP^{cc}$</li>\n<li>$coNP^{cc}\\not\\supseteq RP^{cc}$</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>The notion of communication complexity is to look only at number of information that is being exchanged between multiple parties.</p>\n<h2 id=\"Deterministic-Communication\"><a href=\"#Deterministic-Communication\" class=\"headerlink\" title=\"Deterministic Communication\"></a>Deterministic Communication</h2><h3 id=\"Def-Communication-Complexity\"><a href=\"#Def-Communication-Complexity\" class=\"headerlink\" title=\"Def. Communication Complexity\"></a>Def. Communication Complexity</h3><p>A (communication) protocol $P$ is a rooted binary tree, with each internal node $v$ labelled with a boolean function,<br>$$<br>f_v: \\{0,1\\}^n\\rightarrow\\{0,1\\}<br>$$</p>\n<p>On input $(x,y)$, the computation start from the root. At each internal node, either Alice or Bob sendss one bit. When Alice is speaking, $f_v(x)$ is sent, otherwise, $f_v(y)$ is sent. If $0$ is yield, the protocol go to the left child, otherwise, it goes to the right child. Each leaf node is labelled with output functions,<br>$$<br>f_v: \\{0,1\\}^n\\times\\{0,1\\}^n\\rightarrow\\{0,1\\},<br>$$<br>then output $f(x,y)$. In our setting, we require Alice and Bob to make consensus on their outputs, if not, then whoever knows the output first could send out one output bit, so both would agree on the same output, that would only require one more bit.</p>\n<p>We said the depth of $P$ is the depth of underlying tree. And (communication) complexity of a function $f:\\{0,1\\}^n\\times\\{0,1\\}^n$ be the smallest depth over all possible $P$. For deterministic one, we denote $D^{cc}(f)$.</p>\n<h3 id=\"Cor-D-cc-f-leq-n-1\"><a href=\"#Cor-D-cc-f-leq-n-1\" class=\"headerlink\" title=\"Cor. $D^{cc}(f)\\leq n+1$\"></a>Cor. $D^{cc}(f)\\leq n+1$</h3><p>Simply send all bits at once from Alice to Bob, then send output bits from Bob.</p>\n<h3 id=\"Def-Combinatorial-Rectangle\"><a href=\"#Def-Combinatorial-Rectangle\" class=\"headerlink\" title=\"Def. Combinatorial Rectangle\"></a>Def. Combinatorial Rectangle</h3><p>A (combinatorial) rectangle is a set $A\\times B$ where<br>$$<br>A, B\\subseteq \\{0,1\\}^n.<br>$$</p>\n<p>We care about combinatorial rectangle because it captures the state of communication. Namely, we have the following.</p>\n<h3 id=\"Lem\"><a href=\"#Lem\" class=\"headerlink\" title=\"Lem.\"></a>Lem.</h3><p>Given protocol $P$, node $v$. define $I_v:=\\{(x,y):P$ on $(x,y)$ goes through node $v\\}$. Then $I_v$ is a rectangle.</p>\n<h4 id=\"proof\"><a href=\"#proof\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>Let’s inductively suppose $v$ is a $b$-child of $u$ where $I_u=A\\times B$ is a rectangle. Then $I_v=(A\\cap f^{-1}[b])\\times B$, which is obviously a rectangle. $_\\Box$</p>\n<p>Furthermore, because each $I_v$’s at leaves are necessarily disjoint, we can partitioned all possible inputs into rectangles.</p>\n<h3 id=\"Cor\"><a href=\"#Cor\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>Suppose $P$ is a $c$-bit protocol for $f$, then $\\{0,1\\}^n\\times \\{0,1\\}^n$ could be partitioned into $2^c$ $f$-monochromatic rectangles.</p>\n<h3 id=\"Def\"><a href=\"#Def\" class=\"headerlink\" title=\"Def.\"></a>Def.</h3><p>A $b$-fooling set $S\\subseteq\\{0,1\\}^n\\times\\{0,1\\}^n$ for $f$ is a $b$-monochromatic subset that contains no $b$-monochromatic rectangles of size larger than 1. Equivalently,<br>$$<br>\\forall (x,y)\\in S: f(x,y)=b,\\\\<br>\\forall (x,y),(x’,y’)\\in S: f(x,y’)\\neq b\\lor f(x’,y)\\neq b.<br>$$</p>\n<h3 id=\"Cor-1\"><a href=\"#Cor-1\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>Let $S$ be a $b$-fooling set for $f$, then $D^{cc}(f)\\geq \\lg|S|$.</p>\n<h4 id=\"proof-1\"><a href=\"#proof-1\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>It is because $S$ could collect no more than one ellement from each $f$-monochromatic rectangle, and we could partitioned all possible input into no more than $2^c$ monochromatic rectangle, where $c$ is the depth of $P$. Therefore, we have $2^c\\geq |S|$. $_\\Box$</p>\n<p>The corollary gives a complexity lower bound with respect to size of a fooling set. Techniques using this to provide communication lower bounds are called the <em>fooling set methods</em>. For example, let’s consider the equality problem,<br>$$<br>EQ_n = \\{(x,y)\\in\\{0,1\\}^n\\times\\{0,1\\}^n:x=y\\}.<br>$$<br>Picking $EQ_n$ itself as the $1$-fooling set,<br>$$<br>D^{cc}(EQ_n)\\geq n.<br>$$<br>By looking closer, the lower bound $n$ only contains the $1$-monochromatic rectangles. If we look closer, there must be at least one $0$-monochromatic rectangle contained in the communication matrix. We therefore have the folloing lower bound.</p>\n<h3 id=\"Prop\"><a href=\"#Prop\" class=\"headerlink\" title=\"Prop.\"></a>Prop.</h3><p>$$<br>D^{cc}(EQ_n)\\geq n+1.<br>$$</p>\n<h2 id=\"Non-deterministic-Communication\"><a href=\"#Non-deterministic-Communication\" class=\"headerlink\" title=\"Non-deterministic Communication\"></a>Non-deterministic Communication</h2><p>When walking on the communication tree, we non-deterministically take our step by descending to possibly both childs. We output 1 if one bracnch output 1, otherwise output 0. Equivalently. the notion of non-deterministic communication could also be introduced in the “verifier-certificate” manner. Which is the existence of verifier functions $V_a,V_b:\\{0,1\\}^n\\times \\{0,1\\}^k\\rightarrow \\{0,1\\}$ for both Alice and Bob where,<br>$$<br>x\\in L\\Rightarrow \\exists z\\in\\{0,1\\}^k:V_a(x,z)=1\\land V_b(y,z)=1,\\\\<br>x\\not\\in L\\Rightarrow\\forall z\\in\\{0,1\\}^k:V_a(x,z)=0\\lor V_b(y,z)=0.<br>$$<br>The smallest possible $k$ is the non-deterministic communication complexity, denoted $N_1(f)$. Similarly, we could define the co-non-deterministic communication and $N_0(f)$.</p>\n<p>It follows immediately that, if we choose $0$-certificate as the index of bit pointing to where $x,y$ differ (if there is), then the following upper bound holds.</p>\n<h3 id=\"Cor-2\"><a href=\"#Cor-2\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>$$<br>N_0(EQ_n)\\leq\\lceil\\lg n\\rceil.<br>$$</p>\n<h3 id=\"Def-1\"><a href=\"#Def-1\" class=\"headerlink\" title=\"Def.\"></a>Def.</h3><p>For $f:\\{0,1\\}^n\\times\\{0,1\\}^n\\rightarrow\\{0,1\\}$, the $b$-cover number $C_b(f)$ is defined as the minium number of $b$-monochromatic rectangles $A_i\\times B_i$ that $f(x,y) = \\bigvee_{i}[x\\in A_i\\land y\\in B_i]$.</p>\n<h3 id=\"Lem-1\"><a href=\"#Lem-1\" class=\"headerlink\" title=\"Lem.\"></a>Lem.</h3><p>$$<br>N_b(f)=\\lceil\\lg C_b(f)\\rceil.<br>$$</p>\n<h4 id=\"proof-2\"><a href=\"#proof-2\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>For $N_b(f)\\leq\\lceil\\lg C_b(f)\\rceil$ part, simply choose $b$-certificate be an index pointing to a $b$-monochromatic rectangle. For $N_b(f)\\geq\\lceil\\lg C_b(f)\\rceil$ part, we know that each $b$-certificate $z$ would yield a rectanglel, namely,<br>$$<br>\\{V_a(x,z)=b\\}\\times\\{V_b(y,z)=b\\}.<br>$$<br>These rectangles cover the whole $b$-colorred inputs. Therefore we have,<br>$$<br>2^{N_b(f)}\\geq C_b(f).<br>$$<br>$_\\Box$</p>\n<p>By the similar argument as above, because there is a $1$-fooling set as large as $2^n$ and some $0$-rectangles in $EQ_n$. We have $C_b(EQ_n)\\geq 2^n+1$, therefore we have the following lower bound.</p>\n<h3 id=\"Cor-3\"><a href=\"#Cor-3\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>$$<br>N_1(EQ_n)\\geq n+1.<br>$$</p>\n<h2 id=\"Randomized-Communication\"><a href=\"#Randomized-Communication\" class=\"headerlink\" title=\"Randomized Communication\"></a>Randomized Communication</h2><p>The randomized communication is essentially similar as the previous definition. Except each step here could be performed randomly. We are going to show a protocol that solves $EQ_n$ in $O(\\lg n)$ number of bits.</p>\n<h3 id=\"Cor-4\"><a href=\"#Cor-4\" class=\"headerlink\" title=\"Cor.\"></a>Cor.</h3><p>There exists a $coRP$ communication protocol that resolve $EQ_n$</p>\n<h4 id=\"proof-3\"><a href=\"#proof-3\" class=\"headerlink\" title=\"proof.\"></a>proof.</h4><p>Consider the following protocol.</p>\n<p>On input $x,y$, first we could compute<br>$$<br>p_x(z)=\\sum_{1\\leq i\\leq n}x_iz^i,\\\\<br>p_y(z)=\\sum_{1\\leq i\\leq n}y_iz^i.<br>$$<br>Randomly pick $r\\in\\mathbb{F}$, accept if $p_x(r)=p_y(r)$, otherwise reject.<br>Since a polynomial can only have degree number of roots, by picking $\\mathbb{F}$ to be at least $2$ times larger than $n\\geq\\deg[p_x(z)-p_y(z)]$, we are guaranteed to obtain a $coRP$ protocol, since if $x=y$, the protocol certainly accept, otherwise,<br>$$<br>Pr_r[p_x(r)=p_y(r)]\\leq \\frac{\\deg(p_x-p_y)}{|\\mathbb{F}|}\\leq\\frac{1}{2}.<br>$$<br>$_\\Box$</p>\n<h2 id=\"Complexity-Classes\"><a href=\"#Complexity-Classes\" class=\"headerlink\" title=\"Complexity Classes\"></a>Complexity Classes</h2><p>We sum up with relations between communication complexity classes.</p>\n<h3 id=\"Def-2\"><a href=\"#Def-2\" class=\"headerlink\" title=\"Def.\"></a>Def.</h3><ul>\n<li>$P^{cc}=\\{f:D^{cc}(f)\\leq poly(\\lg n)\\}$</li>\n<li>$NP^{cc}=\\{f:N_1^{cc}(f)\\leq poly(\\lg n)\\}$</li>\n<li>$coNP^{cc}=\\{f:N_0^{cc}(f)\\leq poly(\\lg n)\\}$</li>\n<li>$RP^{cc}=\\{f:\\exists$ RP protocol with complexity $\\leq poly(\\lg n)\\}$</li>\n<li>$coRP^{cc}=\\{f:\\exists$ coRP protocol with complexity $\\leq poly(\\lg n)\\}$</li>\n</ul>\n<h3 id=\"Theorems\"><a href=\"#Theorems\" class=\"headerlink\" title=\"Theorems\"></a>Theorems</h3><p>From above arguement, we conclude the following relations.</p>\n<ul>\n<li>$P^{cc}\\subsetneq RP^{cc}\\subseteq NP^{cc}$</li>\n<li>$P^{cc}\\subsetneq coRP^{cc}\\subseteq coNP^{cc}$</li>\n<li>$NP^{cc}\\neq coNP^{cc}$</li>\n<li>$NP^{cc}\\not\\supseteq coRP^{cc}$</li>\n<li>$coNP^{cc}\\not\\supseteq RP^{cc}$</li>\n</ul>\n"},{"title":"On the Generalised Eigenvalue Problems","date":"2018-11-20T02:00:07.000Z","_content":"\n\n### Standard Eigenvalue Probelm (SEP)\n給定矩陣 $A\\in\\mathbb{C}^{n\\times n}$，求解\n$$\nAx=\\lambda x,x\\neq 0\n$$\n\n### Generalised Eigenvalue Problem (GEP)\n給定矩陣 $A,B\\in\\mathbb{C}^{n\\times n}$，求解\n$$\nAx=\\lambda Bx,x\\neq 0\n$$\n\n如果 $B$ 可逆，那麼這類GEP形同 $B^{-1}A$ 的 SEP，但這個想法計算上並不可行。\n\n- Quadratic Eigenvalue Problem (QEP)\n$$\n(\\lambda^2M+\\lambda D+K)x=0,x\\neq 0\n$$\n對應到 GEP 設定為:\n$$\n\\pmatrix{-D&-M\\\\I&0}\\pmatrix{x\\\\\\lambda x}=\\frac{1}{\\lambda}\\pmatrix{K&0\\\\0&I}\\pmatrix{x\\\\ \\lambda x}\n$$\n\n- Polynomial Eigenvalue Problem (PEP)\n$$\n\\sum_{0\\leq i\\leq n}\\lambda^iA_ix=0,x\\neq 0\n$$\n\n對應到 GEP 設定為:\n$$\n\\pmatrix{-A_1&...&...&-A_n\\\\I&0&...&0\\\\&\\ddots&\\ddots&\\vdots\\\\0&&I&0\n}\\pmatrix{x\\\\\\lambda x\\\\\\vdots\\\\\\lambda^{n-1} x}=\\frac{1}{\\lambda}\\pmatrix{A_0\\\\&I\\\\&&\\ddots\\\\&&&I}\\pmatrix{x\\\\\\lambda x\\\\\\vdots\\\\\\lambda^{n-1} x}\n$$\n\n- Rational Eigenvalue Problem (REP)\n$$\nA(\\lambda)x=x,x\\neq 0,\n$$\n其中 $a_{ij}(\\lambda)\\in Quot(\\mathbb{C}[\\lambda])$ 為有理式。\n\n### 和微分方程的關係\n\n以下不考慮特徵值有重根，這種情況亦有解決手段。\n\n- SEP\n\n考慮偏微分算子\n$$\nD_t:\\pmatrix{x_1\\\\ \\vdots\\\\x_n}\\mapsto \\pmatrix{\\frac{dx_1}{dt}\\\\ \\vdots\\\\ \\frac{dx_n}{dt}}\n$$\n對於 $A\\in\\mathbb{C}^{n\\times n}$ ，一階偏微分方程組\n$$\nD_tx=Ax\n$$\n\n若 $\\lambda\\in\\sigma(A), Av=\\lambda v$，帶入可發現\n$$\nx = v\\cdot e^{\\lambda t}\n$$\n構成一組可行解。\n\n- QEP\n\n考慮帶有阻尼的震動系統\n$$\n(M\\cdot D_t^2+D\\cdot Dt+K)x=0\n$$\n若 $\\lambda,v$ 是一組 Quadratic eigenvalue/eigenvector，那麼帶入\n$$\nx=e^{\\lambda t}v\n$$\n是一組可行解。\n\n### Schrödinger equation\n\n這是量子力學中一類偏微分方程\n$$\n\\hat{H}|\\psi(t)\\rangle=i\\hbar D_t|\\psi(t)\\rangle,\n$$\n其中 $\\hat{H}$ 被稱做 Hamiltonian operator，它可以是與時間有關的線性算子，一般意義下可能與時間相關，如果 $\\hat{H}$ 與時間獨立，那麼考慮其特徵函數 $v$\n$$\n\\hat{H}v=\\lambda v\n$$\n即可令 $e^{\\frac{\\lambda t}{i\\hbar}}v$ 為一組可行的解。\n\n\n例如在計算非相對論性單粒子系統(single nonrelativistic particle)時，引入下面的方程組：\n$$\ni\\hbar D_t \\psi=(\\frac{-\\hbar^2}{2\\mu}\\nabla^2+V)\\psi，\n$$\n其中 $\\nabla^2$ 表示關於空間變數的 Laplacian operator (這個語意下沒有對時間變數做偏微分)，因此在這個例子中所對應的 $\\hat{H}$ 自然是與時間獨立的。\n\n\n特別地，計算中我們往往會對這些系統進行離散化，考慮算子 $\\hat{H}$ 為 finite rank，透過適當的基底選取(或直接假設函數空間為有限維度)，我們有\n\n$$\n\\hat{H}|\\psi\\rangle=A|\\psi\\rangle,A\\in\\mathbb{C}^{n\\times n}。\n$$\n\n例如，上述的非相對論性單粒子系統而言， $\\nabla^2$ 可以透過有限差分構造出離散版本的 Laplacian operator，而 $V$ 則可以表示為一個對角陣所構成的算子。\n\n那麼對於任何一個 SEP 的解，\n$$\nAv=\\lambda v，\n$$\n選擇 $|\\psi(t)\\rangle=e^{\\frac{\\lambda t}{\\hbar i}}v$ 是一組可行解，對於物理學而言，如果 $\\psi$ 獨立於時間變量，那麼得到的特徵值是狀態 $\\psi$ 的能量。\n\n### 後記\nmathjax plugin裝不起來，只好先欠技術債XDD\n```html\n<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script\n    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>\n</script>\n```\n","source":"_posts/On-the-Generalised-Eigenvalue-Problems.md","raw":"---\ntitle: On the Generalised Eigenvalue Problems\ndate: 2018-11-20 03:00:07\ntags: eigenvalue\n---\n\n\n### Standard Eigenvalue Probelm (SEP)\n給定矩陣 $A\\in\\mathbb{C}^{n\\times n}$，求解\n$$\nAx=\\lambda x,x\\neq 0\n$$\n\n### Generalised Eigenvalue Problem (GEP)\n給定矩陣 $A,B\\in\\mathbb{C}^{n\\times n}$，求解\n$$\nAx=\\lambda Bx,x\\neq 0\n$$\n\n如果 $B$ 可逆，那麼這類GEP形同 $B^{-1}A$ 的 SEP，但這個想法計算上並不可行。\n\n- Quadratic Eigenvalue Problem (QEP)\n$$\n(\\lambda^2M+\\lambda D+K)x=0,x\\neq 0\n$$\n對應到 GEP 設定為:\n$$\n\\pmatrix{-D&-M\\\\I&0}\\pmatrix{x\\\\\\lambda x}=\\frac{1}{\\lambda}\\pmatrix{K&0\\\\0&I}\\pmatrix{x\\\\ \\lambda x}\n$$\n\n- Polynomial Eigenvalue Problem (PEP)\n$$\n\\sum_{0\\leq i\\leq n}\\lambda^iA_ix=0,x\\neq 0\n$$\n\n對應到 GEP 設定為:\n$$\n\\pmatrix{-A_1&...&...&-A_n\\\\I&0&...&0\\\\&\\ddots&\\ddots&\\vdots\\\\0&&I&0\n}\\pmatrix{x\\\\\\lambda x\\\\\\vdots\\\\\\lambda^{n-1} x}=\\frac{1}{\\lambda}\\pmatrix{A_0\\\\&I\\\\&&\\ddots\\\\&&&I}\\pmatrix{x\\\\\\lambda x\\\\\\vdots\\\\\\lambda^{n-1} x}\n$$\n\n- Rational Eigenvalue Problem (REP)\n$$\nA(\\lambda)x=x,x\\neq 0,\n$$\n其中 $a_{ij}(\\lambda)\\in Quot(\\mathbb{C}[\\lambda])$ 為有理式。\n\n### 和微分方程的關係\n\n以下不考慮特徵值有重根，這種情況亦有解決手段。\n\n- SEP\n\n考慮偏微分算子\n$$\nD_t:\\pmatrix{x_1\\\\ \\vdots\\\\x_n}\\mapsto \\pmatrix{\\frac{dx_1}{dt}\\\\ \\vdots\\\\ \\frac{dx_n}{dt}}\n$$\n對於 $A\\in\\mathbb{C}^{n\\times n}$ ，一階偏微分方程組\n$$\nD_tx=Ax\n$$\n\n若 $\\lambda\\in\\sigma(A), Av=\\lambda v$，帶入可發現\n$$\nx = v\\cdot e^{\\lambda t}\n$$\n構成一組可行解。\n\n- QEP\n\n考慮帶有阻尼的震動系統\n$$\n(M\\cdot D_t^2+D\\cdot Dt+K)x=0\n$$\n若 $\\lambda,v$ 是一組 Quadratic eigenvalue/eigenvector，那麼帶入\n$$\nx=e^{\\lambda t}v\n$$\n是一組可行解。\n\n### Schrödinger equation\n\n這是量子力學中一類偏微分方程\n$$\n\\hat{H}|\\psi(t)\\rangle=i\\hbar D_t|\\psi(t)\\rangle,\n$$\n其中 $\\hat{H}$ 被稱做 Hamiltonian operator，它可以是與時間有關的線性算子，一般意義下可能與時間相關，如果 $\\hat{H}$ 與時間獨立，那麼考慮其特徵函數 $v$\n$$\n\\hat{H}v=\\lambda v\n$$\n即可令 $e^{\\frac{\\lambda t}{i\\hbar}}v$ 為一組可行的解。\n\n\n例如在計算非相對論性單粒子系統(single nonrelativistic particle)時，引入下面的方程組：\n$$\ni\\hbar D_t \\psi=(\\frac{-\\hbar^2}{2\\mu}\\nabla^2+V)\\psi，\n$$\n其中 $\\nabla^2$ 表示關於空間變數的 Laplacian operator (這個語意下沒有對時間變數做偏微分)，因此在這個例子中所對應的 $\\hat{H}$ 自然是與時間獨立的。\n\n\n特別地，計算中我們往往會對這些系統進行離散化，考慮算子 $\\hat{H}$ 為 finite rank，透過適當的基底選取(或直接假設函數空間為有限維度)，我們有\n\n$$\n\\hat{H}|\\psi\\rangle=A|\\psi\\rangle,A\\in\\mathbb{C}^{n\\times n}。\n$$\n\n例如，上述的非相對論性單粒子系統而言， $\\nabla^2$ 可以透過有限差分構造出離散版本的 Laplacian operator，而 $V$ 則可以表示為一個對角陣所構成的算子。\n\n那麼對於任何一個 SEP 的解，\n$$\nAv=\\lambda v，\n$$\n選擇 $|\\psi(t)\\rangle=e^{\\frac{\\lambda t}{\\hbar i}}v$ 是一組可行解，對於物理學而言，如果 $\\psi$ 獨立於時間變量，那麼得到的特徵值是狀態 $\\psi$ 的能量。\n\n### 後記\nmathjax plugin裝不起來，只好先欠技術債XDD\n```html\n<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script\n    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>\n</script>\n```\n","slug":"On-the-Generalised-Eigenvalue-Problems","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mp40009bx4rpk0mvnp5","content":"<h3 id=\"Standard-Eigenvalue-Probelm-SEP\"><a href=\"#Standard-Eigenvalue-Probelm-SEP\" class=\"headerlink\" title=\"Standard Eigenvalue Probelm (SEP)\"></a>Standard Eigenvalue Probelm (SEP)</h3><p>給定矩陣 $A\\in\\mathbb{C}^{n\\times n}$，求解<br>$$<br>Ax=\\lambda x,x\\neq 0<br>$$</p>\n<h3 id=\"Generalised-Eigenvalue-Problem-GEP\"><a href=\"#Generalised-Eigenvalue-Problem-GEP\" class=\"headerlink\" title=\"Generalised Eigenvalue Problem (GEP)\"></a>Generalised Eigenvalue Problem (GEP)</h3><p>給定矩陣 $A,B\\in\\mathbb{C}^{n\\times n}$，求解<br>$$<br>Ax=\\lambda Bx,x\\neq 0<br>$$</p>\n<p>如果 $B$ 可逆，那麼這類GEP形同 $B^{-1}A$ 的 SEP，但這個想法計算上並不可行。</p>\n<ul>\n<li><p>Quadratic Eigenvalue Problem (QEP)<br>$$<br>(\\lambda^2M+\\lambda D+K)x=0,x\\neq 0<br>$$<br>對應到 GEP 設定為:<br>$$<br>\\pmatrix{-D&amp;-M\\\\I&amp;0}\\pmatrix{x\\\\\\lambda x}=\\frac{1}{\\lambda}\\pmatrix{K&amp;0\\\\0&amp;I}\\pmatrix{x\\ \\lambda x}<br>$$</p>\n</li>\n<li><p>Polynomial Eigenvalue Problem (PEP)<br>$$<br>\\sum_{0\\leq i\\leq n}\\lambda^iA_ix=0,x\\neq 0<br>$$</p>\n</li>\n</ul>\n<p>對應到 GEP 設定為:<br>$$<br>\\pmatrix{-A_1&amp;…&amp;…&amp;-A_n\\\\I&amp;0&amp;…&amp;0\\\\&amp;\\ddots&amp;\\ddots&amp;\\vdots\\\\0&amp;&amp;I&amp;0<br>}\\pmatrix{x\\\\\\lambda x\\\\\\vdots\\\\\\lambda^{n-1} x}=\\frac{1}{\\lambda}\\pmatrix{A_0\\\\&amp;I\\\\&amp;&amp;\\ddots\\\\&amp;&amp;&amp;I}\\pmatrix{x\\\\\\lambda x\\\\\\vdots\\\\\\lambda^{n-1} x}<br>$$</p>\n<ul>\n<li>Rational Eigenvalue Problem (REP)<br>$$<br>A(\\lambda)x=x,x\\neq 0,<br>$$<br>其中 $a_{ij}(\\lambda)\\in Quot(\\mathbb{C}[\\lambda])$ 為有理式。</li>\n</ul>\n<h3 id=\"和微分方程的關係\"><a href=\"#和微分方程的關係\" class=\"headerlink\" title=\"和微分方程的關係\"></a>和微分方程的關係</h3><p>以下不考慮特徵值有重根，這種情況亦有解決手段。</p>\n<ul>\n<li>SEP</li>\n</ul>\n<p>考慮偏微分算子<br>$$<br>D_t:\\pmatrix{x_1\\ \\vdots\\\\x_n}\\mapsto \\pmatrix{\\frac{dx_1}{dt}\\ \\vdots\\ \\frac{dx_n}{dt}}<br>$$<br>對於 $A\\in\\mathbb{C}^{n\\times n}$ ，一階偏微分方程組<br>$$<br>D_tx=Ax<br>$$</p>\n<p>若 $\\lambda\\in\\sigma(A), Av=\\lambda v$，帶入可發現<br>$$<br>x = v\\cdot e^{\\lambda t}<br>$$<br>構成一組可行解。</p>\n<ul>\n<li>QEP</li>\n</ul>\n<p>考慮帶有阻尼的震動系統<br>$$<br>(M\\cdot D_t^2+D\\cdot Dt+K)x=0<br>$$<br>若 $\\lambda,v$ 是一組 Quadratic eigenvalue/eigenvector，那麼帶入<br>$$<br>x=e^{\\lambda t}v<br>$$<br>是一組可行解。</p>\n<h3 id=\"Schrodinger-equation\"><a href=\"#Schrodinger-equation\" class=\"headerlink\" title=\"Schrödinger equation\"></a>Schrödinger equation</h3><p>這是量子力學中一類偏微分方程<br>$$<br>\\hat{H}|\\psi(t)\\rangle=i\\hbar D_t|\\psi(t)\\rangle,<br>$$<br>其中 $\\hat{H}$ 被稱做 Hamiltonian operator，它可以是與時間有關的線性算子，一般意義下可能與時間相關，如果 $\\hat{H}$ 與時間獨立，那麼考慮其特徵函數 $v$<br>$$<br>\\hat{H}v=\\lambda v<br>$$<br>即可令 $e^{\\frac{\\lambda t}{i\\hbar}}v$ 為一組可行的解。</p>\n<p>例如在計算非相對論性單粒子系統(single nonrelativistic particle)時，引入下面的方程組：<br>$$<br>i\\hbar D_t \\psi=(\\frac{-\\hbar^2}{2\\mu}\\nabla^2+V)\\psi，<br>$$<br>其中 $\\nabla^2$ 表示關於空間變數的 Laplacian operator (這個語意下沒有對時間變數做偏微分)，因此在這個例子中所對應的 $\\hat{H}$ 自然是與時間獨立的。</p>\n<p>特別地，計算中我們往往會對這些系統進行離散化，考慮算子 $\\hat{H}$ 為 finite rank，透過適當的基底選取(或直接假設函數空間為有限維度)，我們有</p>\n<p>$$<br>\\hat{H}|\\psi\\rangle=A|\\psi\\rangle,A\\in\\mathbb{C}^{n\\times n}。<br>$$</p>\n<p>例如，上述的非相對論性單粒子系統而言， $\\nabla^2$ 可以透過有限差分構造出離散版本的 Laplacian operator，而 $V$ 則可以表示為一個對角陣所構成的算子。</p>\n<p>那麼對於任何一個 SEP 的解，<br>$$<br>Av=\\lambda v，<br>$$<br>選擇 $|\\psi(t)\\rangle=e^{\\frac{\\lambda t}{\\hbar i}}v$ 是一組可行解，對於物理學而言，如果 $\\psi$ 獨立於時間變量，那麼得到的特徵值是狀態 $\\psi$ 的能量。</p>\n<h3 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h3><p>mathjax plugin裝不起來，只好先欠技術債XDD<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-mathjax-config\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  MathJax.Hub.Config(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    tex2jax: &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],</span></span><br><span class=\"line\"><span class=\"undefined\">      processEscapes: true</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">src</span>=<span class=\"string\">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML'</span> <span class=\"attr\">async</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Standard-Eigenvalue-Probelm-SEP\"><a href=\"#Standard-Eigenvalue-Probelm-SEP\" class=\"headerlink\" title=\"Standard Eigenvalue Probelm (SEP)\"></a>Standard Eigenvalue Probelm (SEP)</h3><p>給定矩陣 $A\\in\\mathbb{C}^{n\\times n}$，求解<br>$$<br>Ax=\\lambda x,x\\neq 0<br>$$</p>\n<h3 id=\"Generalised-Eigenvalue-Problem-GEP\"><a href=\"#Generalised-Eigenvalue-Problem-GEP\" class=\"headerlink\" title=\"Generalised Eigenvalue Problem (GEP)\"></a>Generalised Eigenvalue Problem (GEP)</h3><p>給定矩陣 $A,B\\in\\mathbb{C}^{n\\times n}$，求解<br>$$<br>Ax=\\lambda Bx,x\\neq 0<br>$$</p>\n<p>如果 $B$ 可逆，那麼這類GEP形同 $B^{-1}A$ 的 SEP，但這個想法計算上並不可行。</p>\n<ul>\n<li><p>Quadratic Eigenvalue Problem (QEP)<br>$$<br>(\\lambda^2M+\\lambda D+K)x=0,x\\neq 0<br>$$<br>對應到 GEP 設定為:<br>$$<br>\\pmatrix{-D&amp;-M\\\\I&amp;0}\\pmatrix{x\\\\\\lambda x}=\\frac{1}{\\lambda}\\pmatrix{K&amp;0\\\\0&amp;I}\\pmatrix{x\\ \\lambda x}<br>$$</p>\n</li>\n<li><p>Polynomial Eigenvalue Problem (PEP)<br>$$<br>\\sum_{0\\leq i\\leq n}\\lambda^iA_ix=0,x\\neq 0<br>$$</p>\n</li>\n</ul>\n<p>對應到 GEP 設定為:<br>$$<br>\\pmatrix{-A_1&amp;…&amp;…&amp;-A_n\\\\I&amp;0&amp;…&amp;0\\\\&amp;\\ddots&amp;\\ddots&amp;\\vdots\\\\0&amp;&amp;I&amp;0<br>}\\pmatrix{x\\\\\\lambda x\\\\\\vdots\\\\\\lambda^{n-1} x}=\\frac{1}{\\lambda}\\pmatrix{A_0\\\\&amp;I\\\\&amp;&amp;\\ddots\\\\&amp;&amp;&amp;I}\\pmatrix{x\\\\\\lambda x\\\\\\vdots\\\\\\lambda^{n-1} x}<br>$$</p>\n<ul>\n<li>Rational Eigenvalue Problem (REP)<br>$$<br>A(\\lambda)x=x,x\\neq 0,<br>$$<br>其中 $a_{ij}(\\lambda)\\in Quot(\\mathbb{C}[\\lambda])$ 為有理式。</li>\n</ul>\n<h3 id=\"和微分方程的關係\"><a href=\"#和微分方程的關係\" class=\"headerlink\" title=\"和微分方程的關係\"></a>和微分方程的關係</h3><p>以下不考慮特徵值有重根，這種情況亦有解決手段。</p>\n<ul>\n<li>SEP</li>\n</ul>\n<p>考慮偏微分算子<br>$$<br>D_t:\\pmatrix{x_1\\ \\vdots\\\\x_n}\\mapsto \\pmatrix{\\frac{dx_1}{dt}\\ \\vdots\\ \\frac{dx_n}{dt}}<br>$$<br>對於 $A\\in\\mathbb{C}^{n\\times n}$ ，一階偏微分方程組<br>$$<br>D_tx=Ax<br>$$</p>\n<p>若 $\\lambda\\in\\sigma(A), Av=\\lambda v$，帶入可發現<br>$$<br>x = v\\cdot e^{\\lambda t}<br>$$<br>構成一組可行解。</p>\n<ul>\n<li>QEP</li>\n</ul>\n<p>考慮帶有阻尼的震動系統<br>$$<br>(M\\cdot D_t^2+D\\cdot Dt+K)x=0<br>$$<br>若 $\\lambda,v$ 是一組 Quadratic eigenvalue/eigenvector，那麼帶入<br>$$<br>x=e^{\\lambda t}v<br>$$<br>是一組可行解。</p>\n<h3 id=\"Schrodinger-equation\"><a href=\"#Schrodinger-equation\" class=\"headerlink\" title=\"Schrödinger equation\"></a>Schrödinger equation</h3><p>這是量子力學中一類偏微分方程<br>$$<br>\\hat{H}|\\psi(t)\\rangle=i\\hbar D_t|\\psi(t)\\rangle,<br>$$<br>其中 $\\hat{H}$ 被稱做 Hamiltonian operator，它可以是與時間有關的線性算子，一般意義下可能與時間相關，如果 $\\hat{H}$ 與時間獨立，那麼考慮其特徵函數 $v$<br>$$<br>\\hat{H}v=\\lambda v<br>$$<br>即可令 $e^{\\frac{\\lambda t}{i\\hbar}}v$ 為一組可行的解。</p>\n<p>例如在計算非相對論性單粒子系統(single nonrelativistic particle)時，引入下面的方程組：<br>$$<br>i\\hbar D_t \\psi=(\\frac{-\\hbar^2}{2\\mu}\\nabla^2+V)\\psi，<br>$$<br>其中 $\\nabla^2$ 表示關於空間變數的 Laplacian operator (這個語意下沒有對時間變數做偏微分)，因此在這個例子中所對應的 $\\hat{H}$ 自然是與時間獨立的。</p>\n<p>特別地，計算中我們往往會對這些系統進行離散化，考慮算子 $\\hat{H}$ 為 finite rank，透過適當的基底選取(或直接假設函數空間為有限維度)，我們有</p>\n<p>$$<br>\\hat{H}|\\psi\\rangle=A|\\psi\\rangle,A\\in\\mathbb{C}^{n\\times n}。<br>$$</p>\n<p>例如，上述的非相對論性單粒子系統而言， $\\nabla^2$ 可以透過有限差分構造出離散版本的 Laplacian operator，而 $V$ 則可以表示為一個對角陣所構成的算子。</p>\n<p>那麼對於任何一個 SEP 的解，<br>$$<br>Av=\\lambda v，<br>$$<br>選擇 $|\\psi(t)\\rangle=e^{\\frac{\\lambda t}{\\hbar i}}v$ 是一組可行解，對於物理學而言，如果 $\\psi$ 獨立於時間變量，那麼得到的特徵值是狀態 $\\psi$ 的能量。</p>\n<h3 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h3><p>mathjax plugin裝不起來，只好先欠技術債XDD<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-mathjax-config\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  MathJax.Hub.Config(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    tex2jax: &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],</span></span><br><span class=\"line\"><span class=\"undefined\">      processEscapes: true</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">src</span>=<span class=\"string\">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML'</span> <span class=\"attr\">async</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"Optimality of Grover Search","date":"2019-07-09T17:48:11.000Z","_content":"\nGrover search is a generic pre-image finding algorithm. It is interesting not only as a symmetric crypto adversary, but also as a line that any quantum algorithms cannot go beyond. Particularly, Grover search gives a quadratic and no more than quadratic speed up, which is one of the reasons why quantum algorithm **might not** be able to solve brute-force problems, for instance, NP-complete problems.\n\n### Pre-image Finding Problem\nA preimage finding problem generally gives an oracle $f:\\{0,1\\}^n\\rightarrow\\{0,1\\}$ and ask to find any $x$ that $f(x)=1$, promsing that such $x$ exists (and sometimes more than one). For classical version, algorithms can query one boolean $x$ at a time; the quantum algorithms, on another hand, could be queried a superposition input.\n$$\nO_f:|x\\rangle|b\\rangle\\mapsto |x\\rangle|b\\oplus f(x)\\rangle, \\forall x\\in\\{0,1\\}^n\n$$\n\n\nTo solve this classically, one must do the exponential brute-force to find a pre-image. But since a quantum algorithm could query a superposition at a time, there is the Grover search. The search process is composed of multiple iterations. For each iteration, first we could prepare the following ket from $|\\psi\\rangle$,\n$$\n|\\psi\\rangle=\\sum_{x\\in\\{0,1\\}^n} v_x|x\\rangle\\mapsto\\sum_{x\\in\\{0,1\\}^n} (-1)^{f(x)}v_x|x\\rangle.\n$$\nWe called this step *phase inversion*. Secondly, we flip the magnitude about its mean, namely we apply the following operator,\n$$\n2|+^n\\rangle\\langle+^n|-I.\n$$\nThis operator is clearly unitary because it's eigenvalues are\n$$\n1,-1,\\dots,-1,\n$$\nmultiplicity counted.\n\n### Convergence of Search\nWe are going to show how fast Grover search converges. In particular, it would be requiring $\\Theta(\\sqrt{2^n})$ queries to converge. Let's assume among all possible inputs, with fraction $\\delta$ of them output 1. Consider at the i'th iteration, each search target has magnitude $v_i$, then all other non-targets are with amplitude,\n$$u_i = \\sqrt{\\frac{1-2^n\\delta v_i^2}{2^n-2^n\\delta}}.$$\nThe mean after phase inversion would be,\n$$M_i=(1-\\delta)u_i+\\delta v_i.$$\nThen each iteration will amplify the target amplitude,\n$$v_{i+1} = 2M_i+v_i = 2(1-\\delta)u_i+(1+2\\delta)v_i$$\nSubstitude with $2^n\\delta v_i^2=\\sin^2\\theta_i$. Then since\n$$\nu_i=\\frac{\\cos\\theta_i}{\\sqrt{2^n(1-\\delta)}},\\\\\nv_i=\\frac{\\sin\\theta_i}{\\sqrt{2^n\\delta}},\n$$\nwe have,\n$$\n\\frac{\\sin\\theta_{i+1}}{\\sqrt{2^n\\delta}}=\\frac{2(1-\\delta)\\cos\\theta_i}{\\sqrt{2^n(1-\\delta)}}+\\frac{(1+2\\delta)\\sin\\theta_i}{\\sqrt{2^n\\delta}},\\\\\n\\sin\\theta_{i+1}=2\\sqrt{(1-\\delta)\\delta}\\cos\\theta_i+(1+2\\delta)\\sin\\theta_i.\n$$\nChecking the coeficient square sum do gives us 1. Substitute $\\sin\\phi=2\\sqrt{(1-\\delta)\\delta}$ and $\\cos\\phi=1+2\\delta$. We obtain,\n$$\\sin\\theta_{i+1}=sin(\\theta_i+\\phi)=sin(\\theta_0+q\\phi).$$\nBecause $q\\phi=\\Theta(q\\sqrt{\\delta})$, when $q=\\Theta(\\frac{1}{\\sqrt{\\delta}})$ there is high probability that we will obtain a pre-image of 1. Particularly if such $x$ is unique, the iteration number is $\\Theta(\\sqrt{2^n})$. Before completely converge, the probability of getting a correct answer is $\\sin^2(\\theta_q)=\\Theta(q^2\\delta)$.\n\n\n### Lower Bound of Search\nIn fact, the Grover search algorithm is already the optimal algorithm, in the sense that we have query lower bound for the pre-image finding problem that matches the upper bound of Grover search.\n\nBefore started, we could look at the following lemma. For convenience, we denote $N=2^n$.\n#### Lemma.\nFor $\\alpha, \\beta\\in\\mathbb{C}^N$, if $\\Vert\\alpha\\Vert=\\Vert\\beta\\Vert=1$ and $\\Vert\\alpha-\\beta\\Vert\\leq\\epsilon$, then the probability distribution $D(\\alpha), D(\\beta)$ is as near as,\n$$\n|D(\\alpha)-D(\\beta)|\\leq\\epsilon^2+2\\epsilon\\leq 4\\epsilon.\n$$\n\n*proof*.\nLet $\\alpha=\\sum_i\\alpha_i|i\\rangle$, $\\beta=\\sum_i\\beta_i|i\\rangle$ and $\\gamma=\\alpha-\\beta=\\sum_i\\gamma_i|i\\rangle$. Then\n$$\n(D(\\alpha)-D(\\beta))_i=\\bar{\\alpha_i}\\alpha_i-\\beta_i\\bar{\\beta_i}\\\\\n=(\\beta_i+\\gamma_i)(\\bar{\\beta_i}+\\bar{\\gamma_i})-\\beta_i\\bar{\\beta_i}\\\\\n=\\gamma_i\\bar{\\gamma_i}+\\beta_i\\bar{\\gamma_i}+\\gamma_i\\bar{\\beta_i}\n$$\nThus we have,\n$$\n|D(\\alpha)-D(\\beta)|\\leq \\epsilon^2+\\langle\\gamma|\\beta\\rangle+\\langle\\beta|\\gamma\\rangle\\\\\n\\leq\\epsilon^2+2\\Vert\\gamma\\Vert\\Vert\\beta\\Vert\\leq\\epsilon^2+2\\epsilon. _{\\Box}\n$$\n\nIn another word, as long as the 2-norm of two states is too small, their probability are indistinguishable. It suffice to consider the *phase inversion* oracle.\n\nThen any $q$-query algorithm is composed of \n$$\nU_{q+1}O_fU_q\\dots O_fU_2O_fU_1.\n$$\nWe pick adversary oracle as\n$$\nO_\\tilde{x}:|x\\rangle\\mapsto(-1)^{x=\\tilde{x}}|x\\rangle.\n$$\nComparing this oracle with identity map $Id$, let's denote\n$$\n|\\psi_\\tilde{x}^k\\rangle=O_\\tilde{x}U_k\\dots O_\\tilde{x}U_2O_\\tilde{x}U_1|\\psi_0\\rangle,\\\\\n|\\psi_\\tilde{x}^k\\rangle=U_k\\dots U_2U_1|\\psi_0\\rangle.\n$$\nWe try to bound,\n$$\n\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq\\Vert|U_{k-1}\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^k\\rangle\\Vert\\\\\n=\\Vert O_\\tilde{x}U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle-U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle\\Vert+\\Vert\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^{k-1}\\rangle\\Vert\n$$\nSuppose $U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle=\\sum_{i}u_i|i\\rangle$, then\n$$\n\\Vert O_\\tilde{x}U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle-U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle\\Vert\\leq\\sqrt{4|u_\\tilde{x}|^2}=2|u_\\tilde{x}|.\n$$\nBy Cauchy-Schwarz inequality,\n$$\n\\sum_{\\tilde{x}}|u_\\tilde{x}|\\leq\\sqrt{\\sum_{\\tilde{x}}|u_\\tilde{x}|^2\\cdot N}.\n$$\nSo one could picke one $\\tilde{x}$ below or equal to the average,\n$$\n|u_\\tilde{x}|\\leq \\frac{\\sum_{\\tilde{x}}|u_\\tilde{x}|}{N}\\leq\\frac{1}{\\sqrt{N}}.\n$$\nThen we have\n$$\n\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq \\frac{2}{\\sqrt{N}}+\\Vert|\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^{k-1}\\rangle\\Vert\\leq\\frac{2k}{\\sqrt{N}}.\n$$\nThus, we have probability differ by,\n$$\n|D(|\\psi_\\tilde{x}^q\\rangle)-D(|\\psi_{id}^q\\rangle)|\\leq 4\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq\\frac{8q}{\\sqrt{N}}.\n$$\nIf $O_{\\tilde{x}}$ is distinguishible from id (by some constant difference), we must have,\n$$\n\\Omega(1)\\leq |D(|\\psi_\\tilde{x}^q\\rangle)-D(|\\psi_{id}^q\\rangle)|\\leq \\frac{8q}{\\sqrt{N}}.\n$$\nThus $q\\geq\\Omega(\\sqrt{N})._\\Box$\n\n### Quantum Query Complexity\nThe pre-image finding problem is a search problem, for decisional version, it is $OR_N$ problem. Where we just verify the answer by evaluating whether $H(x)=y$ on given $y$. So with the same logic applied, we have the Quantum query complexity\n$$\nQ(OR_N)=\\Theta(\\sqrt{N})\n$$\n\n","source":"_posts/Optimality-of-Grover-Search.md","raw":"---\ntitle: Optimality of Grover Search\ndate: 2019-07-09 19:48:11\ntags:\n- complexity\n- quantum\n- query complexity\n---\n\nGrover search is a generic pre-image finding algorithm. It is interesting not only as a symmetric crypto adversary, but also as a line that any quantum algorithms cannot go beyond. Particularly, Grover search gives a quadratic and no more than quadratic speed up, which is one of the reasons why quantum algorithm **might not** be able to solve brute-force problems, for instance, NP-complete problems.\n\n### Pre-image Finding Problem\nA preimage finding problem generally gives an oracle $f:\\{0,1\\}^n\\rightarrow\\{0,1\\}$ and ask to find any $x$ that $f(x)=1$, promsing that such $x$ exists (and sometimes more than one). For classical version, algorithms can query one boolean $x$ at a time; the quantum algorithms, on another hand, could be queried a superposition input.\n$$\nO_f:|x\\rangle|b\\rangle\\mapsto |x\\rangle|b\\oplus f(x)\\rangle, \\forall x\\in\\{0,1\\}^n\n$$\n\n\nTo solve this classically, one must do the exponential brute-force to find a pre-image. But since a quantum algorithm could query a superposition at a time, there is the Grover search. The search process is composed of multiple iterations. For each iteration, first we could prepare the following ket from $|\\psi\\rangle$,\n$$\n|\\psi\\rangle=\\sum_{x\\in\\{0,1\\}^n} v_x|x\\rangle\\mapsto\\sum_{x\\in\\{0,1\\}^n} (-1)^{f(x)}v_x|x\\rangle.\n$$\nWe called this step *phase inversion*. Secondly, we flip the magnitude about its mean, namely we apply the following operator,\n$$\n2|+^n\\rangle\\langle+^n|-I.\n$$\nThis operator is clearly unitary because it's eigenvalues are\n$$\n1,-1,\\dots,-1,\n$$\nmultiplicity counted.\n\n### Convergence of Search\nWe are going to show how fast Grover search converges. In particular, it would be requiring $\\Theta(\\sqrt{2^n})$ queries to converge. Let's assume among all possible inputs, with fraction $\\delta$ of them output 1. Consider at the i'th iteration, each search target has magnitude $v_i$, then all other non-targets are with amplitude,\n$$u_i = \\sqrt{\\frac{1-2^n\\delta v_i^2}{2^n-2^n\\delta}}.$$\nThe mean after phase inversion would be,\n$$M_i=(1-\\delta)u_i+\\delta v_i.$$\nThen each iteration will amplify the target amplitude,\n$$v_{i+1} = 2M_i+v_i = 2(1-\\delta)u_i+(1+2\\delta)v_i$$\nSubstitude with $2^n\\delta v_i^2=\\sin^2\\theta_i$. Then since\n$$\nu_i=\\frac{\\cos\\theta_i}{\\sqrt{2^n(1-\\delta)}},\\\\\nv_i=\\frac{\\sin\\theta_i}{\\sqrt{2^n\\delta}},\n$$\nwe have,\n$$\n\\frac{\\sin\\theta_{i+1}}{\\sqrt{2^n\\delta}}=\\frac{2(1-\\delta)\\cos\\theta_i}{\\sqrt{2^n(1-\\delta)}}+\\frac{(1+2\\delta)\\sin\\theta_i}{\\sqrt{2^n\\delta}},\\\\\n\\sin\\theta_{i+1}=2\\sqrt{(1-\\delta)\\delta}\\cos\\theta_i+(1+2\\delta)\\sin\\theta_i.\n$$\nChecking the coeficient square sum do gives us 1. Substitute $\\sin\\phi=2\\sqrt{(1-\\delta)\\delta}$ and $\\cos\\phi=1+2\\delta$. We obtain,\n$$\\sin\\theta_{i+1}=sin(\\theta_i+\\phi)=sin(\\theta_0+q\\phi).$$\nBecause $q\\phi=\\Theta(q\\sqrt{\\delta})$, when $q=\\Theta(\\frac{1}{\\sqrt{\\delta}})$ there is high probability that we will obtain a pre-image of 1. Particularly if such $x$ is unique, the iteration number is $\\Theta(\\sqrt{2^n})$. Before completely converge, the probability of getting a correct answer is $\\sin^2(\\theta_q)=\\Theta(q^2\\delta)$.\n\n\n### Lower Bound of Search\nIn fact, the Grover search algorithm is already the optimal algorithm, in the sense that we have query lower bound for the pre-image finding problem that matches the upper bound of Grover search.\n\nBefore started, we could look at the following lemma. For convenience, we denote $N=2^n$.\n#### Lemma.\nFor $\\alpha, \\beta\\in\\mathbb{C}^N$, if $\\Vert\\alpha\\Vert=\\Vert\\beta\\Vert=1$ and $\\Vert\\alpha-\\beta\\Vert\\leq\\epsilon$, then the probability distribution $D(\\alpha), D(\\beta)$ is as near as,\n$$\n|D(\\alpha)-D(\\beta)|\\leq\\epsilon^2+2\\epsilon\\leq 4\\epsilon.\n$$\n\n*proof*.\nLet $\\alpha=\\sum_i\\alpha_i|i\\rangle$, $\\beta=\\sum_i\\beta_i|i\\rangle$ and $\\gamma=\\alpha-\\beta=\\sum_i\\gamma_i|i\\rangle$. Then\n$$\n(D(\\alpha)-D(\\beta))_i=\\bar{\\alpha_i}\\alpha_i-\\beta_i\\bar{\\beta_i}\\\\\n=(\\beta_i+\\gamma_i)(\\bar{\\beta_i}+\\bar{\\gamma_i})-\\beta_i\\bar{\\beta_i}\\\\\n=\\gamma_i\\bar{\\gamma_i}+\\beta_i\\bar{\\gamma_i}+\\gamma_i\\bar{\\beta_i}\n$$\nThus we have,\n$$\n|D(\\alpha)-D(\\beta)|\\leq \\epsilon^2+\\langle\\gamma|\\beta\\rangle+\\langle\\beta|\\gamma\\rangle\\\\\n\\leq\\epsilon^2+2\\Vert\\gamma\\Vert\\Vert\\beta\\Vert\\leq\\epsilon^2+2\\epsilon. _{\\Box}\n$$\n\nIn another word, as long as the 2-norm of two states is too small, their probability are indistinguishable. It suffice to consider the *phase inversion* oracle.\n\nThen any $q$-query algorithm is composed of \n$$\nU_{q+1}O_fU_q\\dots O_fU_2O_fU_1.\n$$\nWe pick adversary oracle as\n$$\nO_\\tilde{x}:|x\\rangle\\mapsto(-1)^{x=\\tilde{x}}|x\\rangle.\n$$\nComparing this oracle with identity map $Id$, let's denote\n$$\n|\\psi_\\tilde{x}^k\\rangle=O_\\tilde{x}U_k\\dots O_\\tilde{x}U_2O_\\tilde{x}U_1|\\psi_0\\rangle,\\\\\n|\\psi_\\tilde{x}^k\\rangle=U_k\\dots U_2U_1|\\psi_0\\rangle.\n$$\nWe try to bound,\n$$\n\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq\\Vert|U_{k-1}\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^k\\rangle\\Vert\\\\\n=\\Vert O_\\tilde{x}U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle-U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle\\Vert+\\Vert\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^{k-1}\\rangle\\Vert\n$$\nSuppose $U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle=\\sum_{i}u_i|i\\rangle$, then\n$$\n\\Vert O_\\tilde{x}U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle-U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle\\Vert\\leq\\sqrt{4|u_\\tilde{x}|^2}=2|u_\\tilde{x}|.\n$$\nBy Cauchy-Schwarz inequality,\n$$\n\\sum_{\\tilde{x}}|u_\\tilde{x}|\\leq\\sqrt{\\sum_{\\tilde{x}}|u_\\tilde{x}|^2\\cdot N}.\n$$\nSo one could picke one $\\tilde{x}$ below or equal to the average,\n$$\n|u_\\tilde{x}|\\leq \\frac{\\sum_{\\tilde{x}}|u_\\tilde{x}|}{N}\\leq\\frac{1}{\\sqrt{N}}.\n$$\nThen we have\n$$\n\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq \\frac{2}{\\sqrt{N}}+\\Vert|\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^{k-1}\\rangle\\Vert\\leq\\frac{2k}{\\sqrt{N}}.\n$$\nThus, we have probability differ by,\n$$\n|D(|\\psi_\\tilde{x}^q\\rangle)-D(|\\psi_{id}^q\\rangle)|\\leq 4\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq\\frac{8q}{\\sqrt{N}}.\n$$\nIf $O_{\\tilde{x}}$ is distinguishible from id (by some constant difference), we must have,\n$$\n\\Omega(1)\\leq |D(|\\psi_\\tilde{x}^q\\rangle)-D(|\\psi_{id}^q\\rangle)|\\leq \\frac{8q}{\\sqrt{N}}.\n$$\nThus $q\\geq\\Omega(\\sqrt{N})._\\Box$\n\n### Quantum Query Complexity\nThe pre-image finding problem is a search problem, for decisional version, it is $OR_N$ problem. Where we just verify the answer by evaluating whether $H(x)=y$ on given $y$. So with the same logic applied, we have the Quantum query complexity\n$$\nQ(OR_N)=\\Theta(\\sqrt{N})\n$$\n\n","slug":"Optimality-of-Grover-Search","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mp6000cbx4rmslnx34t","content":"<p>Grover search is a generic pre-image finding algorithm. It is interesting not only as a symmetric crypto adversary, but also as a line that any quantum algorithms cannot go beyond. Particularly, Grover search gives a quadratic and no more than quadratic speed up, which is one of the reasons why quantum algorithm <strong>might not</strong> be able to solve brute-force problems, for instance, NP-complete problems.</p>\n<h3 id=\"Pre-image-Finding-Problem\"><a href=\"#Pre-image-Finding-Problem\" class=\"headerlink\" title=\"Pre-image Finding Problem\"></a>Pre-image Finding Problem</h3><p>A preimage finding problem generally gives an oracle $f:\\{0,1\\}^n\\rightarrow\\{0,1\\}$ and ask to find any $x$ that $f(x)=1$, promsing that such $x$ exists (and sometimes more than one). For classical version, algorithms can query one boolean $x$ at a time; the quantum algorithms, on another hand, could be queried a superposition input.<br>$$<br>O_f:|x\\rangle|b\\rangle\\mapsto |x\\rangle|b\\oplus f(x)\\rangle, \\forall x\\in\\{0,1\\}^n<br>$$</p>\n<p>To solve this classically, one must do the exponential brute-force to find a pre-image. But since a quantum algorithm could query a superposition at a time, there is the Grover search. The search process is composed of multiple iterations. For each iteration, first we could prepare the following ket from $|\\psi\\rangle$,<br>$$<br>|\\psi\\rangle=\\sum_{x\\in\\{0,1\\}^n} v_x|x\\rangle\\mapsto\\sum_{x\\in\\{0,1\\}^n} (-1)^{f(x)}v_x|x\\rangle.<br>$$<br>We called this step <em>phase inversion</em>. Secondly, we flip the magnitude about its mean, namely we apply the following operator,<br>$$<br>2|+^n\\rangle\\langle+^n|-I.<br>$$<br>This operator is clearly unitary because it’s eigenvalues are<br>$$<br>1,-1,\\dots,-1,<br>$$<br>multiplicity counted.</p>\n<h3 id=\"Convergence-of-Search\"><a href=\"#Convergence-of-Search\" class=\"headerlink\" title=\"Convergence of Search\"></a>Convergence of Search</h3><p>We are going to show how fast Grover search converges. In particular, it would be requiring $\\Theta(\\sqrt{2^n})$ queries to converge. Let’s assume among all possible inputs, with fraction $\\delta$ of them output 1. Consider at the i’th iteration, each search target has magnitude $v_i$, then all other non-targets are with amplitude,<br>$$u_i = \\sqrt{\\frac{1-2^n\\delta v_i^2}{2^n-2^n\\delta}}.$$<br>The mean after phase inversion would be,<br>$$M_i=(1-\\delta)u_i+\\delta v_i.$$<br>Then each iteration will amplify the target amplitude,<br>$$v_{i+1} = 2M_i+v_i = 2(1-\\delta)u_i+(1+2\\delta)v_i$$<br>Substitude with $2^n\\delta v_i^2=\\sin^2\\theta_i$. Then since<br>$$<br>u_i=\\frac{\\cos\\theta_i}{\\sqrt{2^n(1-\\delta)}},\\\\<br>v_i=\\frac{\\sin\\theta_i}{\\sqrt{2^n\\delta}},<br>$$<br>we have,<br>$$<br>\\frac{\\sin\\theta_{i+1}}{\\sqrt{2^n\\delta}}=\\frac{2(1-\\delta)\\cos\\theta_i}{\\sqrt{2^n(1-\\delta)}}+\\frac{(1+2\\delta)\\sin\\theta_i}{\\sqrt{2^n\\delta}},\\\\<br>\\sin\\theta_{i+1}=2\\sqrt{(1-\\delta)\\delta}\\cos\\theta_i+(1+2\\delta)\\sin\\theta_i.<br>$$<br>Checking the coeficient square sum do gives us 1. Substitute $\\sin\\phi=2\\sqrt{(1-\\delta)\\delta}$ and $\\cos\\phi=1+2\\delta$. We obtain,<br>$$\\sin\\theta_{i+1}=sin(\\theta_i+\\phi)=sin(\\theta_0+q\\phi).$$<br>Because $q\\phi=\\Theta(q\\sqrt{\\delta})$, when $q=\\Theta(\\frac{1}{\\sqrt{\\delta}})$ there is high probability that we will obtain a pre-image of 1. Particularly if such $x$ is unique, the iteration number is $\\Theta(\\sqrt{2^n})$. Before completely converge, the probability of getting a correct answer is $\\sin^2(\\theta_q)=\\Theta(q^2\\delta)$.</p>\n<h3 id=\"Lower-Bound-of-Search\"><a href=\"#Lower-Bound-of-Search\" class=\"headerlink\" title=\"Lower Bound of Search\"></a>Lower Bound of Search</h3><p>In fact, the Grover search algorithm is already the optimal algorithm, in the sense that we have query lower bound for the pre-image finding problem that matches the upper bound of Grover search.</p>\n<p>Before started, we could look at the following lemma. For convenience, we denote $N=2^n$.</p>\n<h4 id=\"Lemma\"><a href=\"#Lemma\" class=\"headerlink\" title=\"Lemma.\"></a>Lemma.</h4><p>For $\\alpha, \\beta\\in\\mathbb{C}^N$, if $\\Vert\\alpha\\Vert=\\Vert\\beta\\Vert=1$ and $\\Vert\\alpha-\\beta\\Vert\\leq\\epsilon$, then the probability distribution $D(\\alpha), D(\\beta)$ is as near as,<br>$$<br>|D(\\alpha)-D(\\beta)|\\leq\\epsilon^2+2\\epsilon\\leq 4\\epsilon.<br>$$</p>\n<p><em>proof</em>.<br>Let $\\alpha=\\sum_i\\alpha_i|i\\rangle$, $\\beta=\\sum_i\\beta_i|i\\rangle$ and $\\gamma=\\alpha-\\beta=\\sum_i\\gamma_i|i\\rangle$. Then<br>$$<br>(D(\\alpha)-D(\\beta))_i=\\bar{\\alpha_i}\\alpha_i-\\beta_i\\bar{\\beta_i}\\\\<br>=(\\beta_i+\\gamma_i)(\\bar{\\beta_i}+\\bar{\\gamma_i})-\\beta_i\\bar{\\beta_i}\\\\<br>=\\gamma_i\\bar{\\gamma_i}+\\beta_i\\bar{\\gamma_i}+\\gamma_i\\bar{\\beta_i}<br>$$<br>Thus we have,<br>$$<br>|D(\\alpha)-D(\\beta)|\\leq \\epsilon^2+\\langle\\gamma|\\beta\\rangle+\\langle\\beta|\\gamma\\rangle\\\\<br>\\leq\\epsilon^2+2\\Vert\\gamma\\Vert\\Vert\\beta\\Vert\\leq\\epsilon^2+2\\epsilon. _{\\Box}<br>$$</p>\n<p>In another word, as long as the 2-norm of two states is too small, their probability are indistinguishable. It suffice to consider the <em>phase inversion</em> oracle.</p>\n<p>Then any $q$-query algorithm is composed of<br>$$<br>U_{q+1}O_fU_q\\dots O_fU_2O_fU_1.<br>$$<br>We pick adversary oracle as<br>$$<br>O_\\tilde{x}:|x\\rangle\\mapsto(-1)^{x=\\tilde{x}}|x\\rangle.<br>$$<br>Comparing this oracle with identity map $Id$, let’s denote<br>$$<br>|\\psi_\\tilde{x}^k\\rangle=O_\\tilde{x}U_k\\dots O_\\tilde{x}U_2O_\\tilde{x}U_1|\\psi_0\\rangle,\\\\<br>|\\psi_\\tilde{x}^k\\rangle=U_k\\dots U_2U_1|\\psi_0\\rangle.<br>$$<br>We try to bound,<br>$$<br>\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq\\Vert|U_{k-1}\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^k\\rangle\\Vert\\\\<br>=\\Vert O_\\tilde{x}U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle-U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle\\Vert+\\Vert\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^{k-1}\\rangle\\Vert<br>$$<br>Suppose $U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle=\\sum_{i}u_i|i\\rangle$, then<br>$$<br>\\Vert O_\\tilde{x}U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle-U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle\\Vert\\leq\\sqrt{4|u_\\tilde{x}|^2}=2|u_\\tilde{x}|.<br>$$<br>By Cauchy-Schwarz inequality,<br>$$<br>\\sum_{\\tilde{x}}|u_\\tilde{x}|\\leq\\sqrt{\\sum_{\\tilde{x}}|u_\\tilde{x}|^2\\cdot N}.<br>$$<br>So one could picke one $\\tilde{x}$ below or equal to the average,<br>$$<br>|u_\\tilde{x}|\\leq \\frac{\\sum_{\\tilde{x}}|u_\\tilde{x}|}{N}\\leq\\frac{1}{\\sqrt{N}}.<br>$$<br>Then we have<br>$$<br>\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq \\frac{2}{\\sqrt{N}}+\\Vert|\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^{k-1}\\rangle\\Vert\\leq\\frac{2k}{\\sqrt{N}}.<br>$$<br>Thus, we have probability differ by,<br>$$<br>|D(|\\psi_\\tilde{x}^q\\rangle)-D(|\\psi_{id}^q\\rangle)|\\leq 4\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq\\frac{8q}{\\sqrt{N}}.<br>$$<br>If $O_{\\tilde{x}}$ is distinguishible from id (by some constant difference), we must have,<br>$$<br>\\Omega(1)\\leq |D(|\\psi_\\tilde{x}^q\\rangle)-D(|\\psi_{id}^q\\rangle)|\\leq \\frac{8q}{\\sqrt{N}}.<br>$$<br>Thus $q\\geq\\Omega(\\sqrt{N})._\\Box$</p>\n<h3 id=\"Quantum-Query-Complexity\"><a href=\"#Quantum-Query-Complexity\" class=\"headerlink\" title=\"Quantum Query Complexity\"></a>Quantum Query Complexity</h3><p>The pre-image finding problem is a search problem, for decisional version, it is $OR_N$ problem. Where we just verify the answer by evaluating whether $H(x)=y$ on given $y$. So with the same logic applied, we have the Quantum query complexity<br>$$<br>Q(OR_N)=\\Theta(\\sqrt{N})<br>$$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Grover search is a generic pre-image finding algorithm. It is interesting not only as a symmetric crypto adversary, but also as a line that any quantum algorithms cannot go beyond. Particularly, Grover search gives a quadratic and no more than quadratic speed up, which is one of the reasons why quantum algorithm <strong>might not</strong> be able to solve brute-force problems, for instance, NP-complete problems.</p>\n<h3 id=\"Pre-image-Finding-Problem\"><a href=\"#Pre-image-Finding-Problem\" class=\"headerlink\" title=\"Pre-image Finding Problem\"></a>Pre-image Finding Problem</h3><p>A preimage finding problem generally gives an oracle $f:\\{0,1\\}^n\\rightarrow\\{0,1\\}$ and ask to find any $x$ that $f(x)=1$, promsing that such $x$ exists (and sometimes more than one). For classical version, algorithms can query one boolean $x$ at a time; the quantum algorithms, on another hand, could be queried a superposition input.<br>$$<br>O_f:|x\\rangle|b\\rangle\\mapsto |x\\rangle|b\\oplus f(x)\\rangle, \\forall x\\in\\{0,1\\}^n<br>$$</p>\n<p>To solve this classically, one must do the exponential brute-force to find a pre-image. But since a quantum algorithm could query a superposition at a time, there is the Grover search. The search process is composed of multiple iterations. For each iteration, first we could prepare the following ket from $|\\psi\\rangle$,<br>$$<br>|\\psi\\rangle=\\sum_{x\\in\\{0,1\\}^n} v_x|x\\rangle\\mapsto\\sum_{x\\in\\{0,1\\}^n} (-1)^{f(x)}v_x|x\\rangle.<br>$$<br>We called this step <em>phase inversion</em>. Secondly, we flip the magnitude about its mean, namely we apply the following operator,<br>$$<br>2|+^n\\rangle\\langle+^n|-I.<br>$$<br>This operator is clearly unitary because it’s eigenvalues are<br>$$<br>1,-1,\\dots,-1,<br>$$<br>multiplicity counted.</p>\n<h3 id=\"Convergence-of-Search\"><a href=\"#Convergence-of-Search\" class=\"headerlink\" title=\"Convergence of Search\"></a>Convergence of Search</h3><p>We are going to show how fast Grover search converges. In particular, it would be requiring $\\Theta(\\sqrt{2^n})$ queries to converge. Let’s assume among all possible inputs, with fraction $\\delta$ of them output 1. Consider at the i’th iteration, each search target has magnitude $v_i$, then all other non-targets are with amplitude,<br>$$u_i = \\sqrt{\\frac{1-2^n\\delta v_i^2}{2^n-2^n\\delta}}.$$<br>The mean after phase inversion would be,<br>$$M_i=(1-\\delta)u_i+\\delta v_i.$$<br>Then each iteration will amplify the target amplitude,<br>$$v_{i+1} = 2M_i+v_i = 2(1-\\delta)u_i+(1+2\\delta)v_i$$<br>Substitude with $2^n\\delta v_i^2=\\sin^2\\theta_i$. Then since<br>$$<br>u_i=\\frac{\\cos\\theta_i}{\\sqrt{2^n(1-\\delta)}},\\\\<br>v_i=\\frac{\\sin\\theta_i}{\\sqrt{2^n\\delta}},<br>$$<br>we have,<br>$$<br>\\frac{\\sin\\theta_{i+1}}{\\sqrt{2^n\\delta}}=\\frac{2(1-\\delta)\\cos\\theta_i}{\\sqrt{2^n(1-\\delta)}}+\\frac{(1+2\\delta)\\sin\\theta_i}{\\sqrt{2^n\\delta}},\\\\<br>\\sin\\theta_{i+1}=2\\sqrt{(1-\\delta)\\delta}\\cos\\theta_i+(1+2\\delta)\\sin\\theta_i.<br>$$<br>Checking the coeficient square sum do gives us 1. Substitute $\\sin\\phi=2\\sqrt{(1-\\delta)\\delta}$ and $\\cos\\phi=1+2\\delta$. We obtain,<br>$$\\sin\\theta_{i+1}=sin(\\theta_i+\\phi)=sin(\\theta_0+q\\phi).$$<br>Because $q\\phi=\\Theta(q\\sqrt{\\delta})$, when $q=\\Theta(\\frac{1}{\\sqrt{\\delta}})$ there is high probability that we will obtain a pre-image of 1. Particularly if such $x$ is unique, the iteration number is $\\Theta(\\sqrt{2^n})$. Before completely converge, the probability of getting a correct answer is $\\sin^2(\\theta_q)=\\Theta(q^2\\delta)$.</p>\n<h3 id=\"Lower-Bound-of-Search\"><a href=\"#Lower-Bound-of-Search\" class=\"headerlink\" title=\"Lower Bound of Search\"></a>Lower Bound of Search</h3><p>In fact, the Grover search algorithm is already the optimal algorithm, in the sense that we have query lower bound for the pre-image finding problem that matches the upper bound of Grover search.</p>\n<p>Before started, we could look at the following lemma. For convenience, we denote $N=2^n$.</p>\n<h4 id=\"Lemma\"><a href=\"#Lemma\" class=\"headerlink\" title=\"Lemma.\"></a>Lemma.</h4><p>For $\\alpha, \\beta\\in\\mathbb{C}^N$, if $\\Vert\\alpha\\Vert=\\Vert\\beta\\Vert=1$ and $\\Vert\\alpha-\\beta\\Vert\\leq\\epsilon$, then the probability distribution $D(\\alpha), D(\\beta)$ is as near as,<br>$$<br>|D(\\alpha)-D(\\beta)|\\leq\\epsilon^2+2\\epsilon\\leq 4\\epsilon.<br>$$</p>\n<p><em>proof</em>.<br>Let $\\alpha=\\sum_i\\alpha_i|i\\rangle$, $\\beta=\\sum_i\\beta_i|i\\rangle$ and $\\gamma=\\alpha-\\beta=\\sum_i\\gamma_i|i\\rangle$. Then<br>$$<br>(D(\\alpha)-D(\\beta))_i=\\bar{\\alpha_i}\\alpha_i-\\beta_i\\bar{\\beta_i}\\\\<br>=(\\beta_i+\\gamma_i)(\\bar{\\beta_i}+\\bar{\\gamma_i})-\\beta_i\\bar{\\beta_i}\\\\<br>=\\gamma_i\\bar{\\gamma_i}+\\beta_i\\bar{\\gamma_i}+\\gamma_i\\bar{\\beta_i}<br>$$<br>Thus we have,<br>$$<br>|D(\\alpha)-D(\\beta)|\\leq \\epsilon^2+\\langle\\gamma|\\beta\\rangle+\\langle\\beta|\\gamma\\rangle\\\\<br>\\leq\\epsilon^2+2\\Vert\\gamma\\Vert\\Vert\\beta\\Vert\\leq\\epsilon^2+2\\epsilon. _{\\Box}<br>$$</p>\n<p>In another word, as long as the 2-norm of two states is too small, their probability are indistinguishable. It suffice to consider the <em>phase inversion</em> oracle.</p>\n<p>Then any $q$-query algorithm is composed of<br>$$<br>U_{q+1}O_fU_q\\dots O_fU_2O_fU_1.<br>$$<br>We pick adversary oracle as<br>$$<br>O_\\tilde{x}:|x\\rangle\\mapsto(-1)^{x=\\tilde{x}}|x\\rangle.<br>$$<br>Comparing this oracle with identity map $Id$, let’s denote<br>$$<br>|\\psi_\\tilde{x}^k\\rangle=O_\\tilde{x}U_k\\dots O_\\tilde{x}U_2O_\\tilde{x}U_1|\\psi_0\\rangle,\\\\<br>|\\psi_\\tilde{x}^k\\rangle=U_k\\dots U_2U_1|\\psi_0\\rangle.<br>$$<br>We try to bound,<br>$$<br>\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq\\Vert|U_{k-1}\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^k\\rangle\\Vert\\\\<br>=\\Vert O_\\tilde{x}U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle-U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle\\Vert+\\Vert\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^{k-1}\\rangle\\Vert<br>$$<br>Suppose $U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle=\\sum_{i}u_i|i\\rangle$, then<br>$$<br>\\Vert O_\\tilde{x}U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle-U_{k-1}|\\psi_\\tilde{x}^{k-1}\\rangle\\Vert\\leq\\sqrt{4|u_\\tilde{x}|^2}=2|u_\\tilde{x}|.<br>$$<br>By Cauchy-Schwarz inequality,<br>$$<br>\\sum_{\\tilde{x}}|u_\\tilde{x}|\\leq\\sqrt{\\sum_{\\tilde{x}}|u_\\tilde{x}|^2\\cdot N}.<br>$$<br>So one could picke one $\\tilde{x}$ below or equal to the average,<br>$$<br>|u_\\tilde{x}|\\leq \\frac{\\sum_{\\tilde{x}}|u_\\tilde{x}|}{N}\\leq\\frac{1}{\\sqrt{N}}.<br>$$<br>Then we have<br>$$<br>\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq \\frac{2}{\\sqrt{N}}+\\Vert|\\psi_\\tilde{x}^{k-1}\\rangle-|\\psi_{id}^{k-1}\\rangle\\Vert\\leq\\frac{2k}{\\sqrt{N}}.<br>$$<br>Thus, we have probability differ by,<br>$$<br>|D(|\\psi_\\tilde{x}^q\\rangle)-D(|\\psi_{id}^q\\rangle)|\\leq 4\\Vert|\\psi_\\tilde{x}^k\\rangle-|\\psi_{id}^k\\rangle\\Vert\\leq\\frac{8q}{\\sqrt{N}}.<br>$$<br>If $O_{\\tilde{x}}$ is distinguishible from id (by some constant difference), we must have,<br>$$<br>\\Omega(1)\\leq |D(|\\psi_\\tilde{x}^q\\rangle)-D(|\\psi_{id}^q\\rangle)|\\leq \\frac{8q}{\\sqrt{N}}.<br>$$<br>Thus $q\\geq\\Omega(\\sqrt{N})._\\Box$</p>\n<h3 id=\"Quantum-Query-Complexity\"><a href=\"#Quantum-Query-Complexity\" class=\"headerlink\" title=\"Quantum Query Complexity\"></a>Quantum Query Complexity</h3><p>The pre-image finding problem is a search problem, for decisional version, it is $OR_N$ problem. Where we just verify the answer by evaluating whether $H(x)=y$ on given $y$. So with the same logic applied, we have the Quantum query complexity<br>$$<br>Q(OR_N)=\\Theta(\\sqrt{N})<br>$$</p>\n"},{"title":"Prologue: UIUC","date":"2019-01-12T22:13:52.000Z","_content":"\nUIUC is a prestigious research university in the US.\nMy friends (Mickey, Cosmos) and I are incoming exchange students and about to live a full semester here. Let's see what heppened in the first week before lectures begin.\n\n### Cooking\n\nFood price in US is way much more expensive than it was in Taiwan. So we usually cook for our self.\n<img src=\"https://i.imgur.com/IaJndYb.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/ZZk2o1b.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/vZx24KO.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/KU8iqZ5.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/FQvByUn.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/XGvMHO0.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/PcP52An.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/jHfOzv7.jpg\" width=50% height=50%>\n\n### Environment\n\n\nUIUC is located in Urbana Champaign. The surrounding is quite nice. And there's a cute  sign in front of ISSS (International Student and Scholar Services) checkin place.\n\n<img src=\"https://i.imgur.com/JTf9HtM.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/IouF3nz.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/dL3XpvH.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/0y2val1.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/r5pWMkQ.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/Z80LIzu.jpg\" width=50% height=50%>\n\nFew days later, it starts to snow. Then we build a couple of snow men.\n\n<img src=\"https://i.imgur.com/9tlCqo2.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/5JNmI1N.jpg\" width=50% height=50%>\n\n### Orientation\n\nUseful info and some fun activities. We get to see fancy engineering equipments.\n<img src=\"https://i.imgur.com/d795QbX.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/1XnrBUW.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/sGSr3Iu.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/SvFCLVa.jpg\" width=50% height=50%>\n","source":"_posts/Prologue-UIUC.md","raw":"---\ntitle: 'Prologue: UIUC'\ndate: 2019-01-12 23:13:52\ntags:\n---\n\nUIUC is a prestigious research university in the US.\nMy friends (Mickey, Cosmos) and I are incoming exchange students and about to live a full semester here. Let's see what heppened in the first week before lectures begin.\n\n### Cooking\n\nFood price in US is way much more expensive than it was in Taiwan. So we usually cook for our self.\n<img src=\"https://i.imgur.com/IaJndYb.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/ZZk2o1b.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/vZx24KO.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/KU8iqZ5.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/FQvByUn.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/XGvMHO0.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/PcP52An.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/jHfOzv7.jpg\" width=50% height=50%>\n\n### Environment\n\n\nUIUC is located in Urbana Champaign. The surrounding is quite nice. And there's a cute  sign in front of ISSS (International Student and Scholar Services) checkin place.\n\n<img src=\"https://i.imgur.com/JTf9HtM.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/IouF3nz.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/dL3XpvH.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/0y2val1.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/r5pWMkQ.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/Z80LIzu.jpg\" width=50% height=50%>\n\nFew days later, it starts to snow. Then we build a couple of snow men.\n\n<img src=\"https://i.imgur.com/9tlCqo2.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/5JNmI1N.jpg\" width=50% height=50%>\n\n### Orientation\n\nUseful info and some fun activities. We get to see fancy engineering equipments.\n<img src=\"https://i.imgur.com/d795QbX.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/1XnrBUW.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/sGSr3Iu.jpg\" width=50% height=50%><img src=\"https://i.imgur.com/SvFCLVa.jpg\" width=50% height=50%>\n","slug":"Prologue-UIUC","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mp7000dbx4r0t6m2bnx","content":"<p>UIUC is a prestigious research university in the US.<br>My friends (Mickey, Cosmos) and I are incoming exchange students and about to live a full semester here. Let’s see what heppened in the first week before lectures begin.</p>\n<h3 id=\"Cooking\"><a href=\"#Cooking\" class=\"headerlink\" title=\"Cooking\"></a>Cooking</h3><p>Food price in US is way much more expensive than it was in Taiwan. So we usually cook for our self.<br><img src=\"https://i.imgur.com/IaJndYb.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/ZZk2o1b.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/vZx24KO.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/KU8iqZ5.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/FQvByUn.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/XGvMHO0.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/PcP52An.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/jHfOzv7.jpg\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>UIUC is located in Urbana Champaign. The surrounding is quite nice. And there’s a cute  sign in front of ISSS (International Student and Scholar Services) checkin place.</p>\n<p><img src=\"https://i.imgur.com/JTf9HtM.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/IouF3nz.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/dL3XpvH.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/0y2val1.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/r5pWMkQ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/Z80LIzu.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>Few days later, it starts to snow. Then we build a couple of snow men.</p>\n<p><img src=\"https://i.imgur.com/9tlCqo2.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/5JNmI1N.jpg\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"Orientation\"><a href=\"#Orientation\" class=\"headerlink\" title=\"Orientation\"></a>Orientation</h3><p>Useful info and some fun activities. We get to see fancy engineering equipments.<br><img src=\"https://i.imgur.com/d795QbX.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/1XnrBUW.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/sGSr3Iu.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/SvFCLVa.jpg\" width=\"50%\" height=\"50%\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>UIUC is a prestigious research university in the US.<br>My friends (Mickey, Cosmos) and I are incoming exchange students and about to live a full semester here. Let’s see what heppened in the first week before lectures begin.</p>\n<h3 id=\"Cooking\"><a href=\"#Cooking\" class=\"headerlink\" title=\"Cooking\"></a>Cooking</h3><p>Food price in US is way much more expensive than it was in Taiwan. So we usually cook for our self.<br><img src=\"https://i.imgur.com/IaJndYb.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/ZZk2o1b.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/vZx24KO.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/KU8iqZ5.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/FQvByUn.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/XGvMHO0.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/PcP52An.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/jHfOzv7.jpg\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>UIUC is located in Urbana Champaign. The surrounding is quite nice. And there’s a cute  sign in front of ISSS (International Student and Scholar Services) checkin place.</p>\n<p><img src=\"https://i.imgur.com/JTf9HtM.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/IouF3nz.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/dL3XpvH.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/0y2val1.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/r5pWMkQ.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/Z80LIzu.jpg\" width=\"50%\" height=\"50%\"></p>\n<p>Few days later, it starts to snow. Then we build a couple of snow men.</p>\n<p><img src=\"https://i.imgur.com/9tlCqo2.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/5JNmI1N.jpg\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"Orientation\"><a href=\"#Orientation\" class=\"headerlink\" title=\"Orientation\"></a>Orientation</h3><p>Useful info and some fun activities. We get to see fancy engineering equipments.<br><img src=\"https://i.imgur.com/d795QbX.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/1XnrBUW.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/sGSr3Iu.jpg\" width=\"50%\" height=\"50%\"><img src=\"https://i.imgur.com/SvFCLVa.jpg\" width=\"50%\" height=\"50%\"></p>\n"},{"title":"Quick Note on the Continued Fraction","date":"2018-11-24T02:07:49.000Z","_content":"<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script\n    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>\n</script>\n\n本文將簡述連分數，有些內容之後視情況將斟酌補充。\n\n![](https://i.imgur.com/Tht0evZ.png)\n\n連分數在數學上是一個有趣的主題，小時候大家玩過摺紙遊戲，把長方形的紙片等角對折，剪去以折線為對角的正方形，然後不斷重複做一樣的事情之後，把同樣大小的正方形蒐集起來，這時候正方形由大到小的個數就構成了一個連分數。\n\n\n### Definition\n\n考慮一串整數的序列，\n$$\na_0,a_1,a_2,...\n$$\n其中 $a_i\\geq 0,\\forall i>0$。\n我們定義有限項連分數，\n$$\ns_n=[a_0;a_1,a_2,...,a_n]:=a_0+\\frac{1}{a_1+\\frac{1}{a_2+\\frac{...}{a_n}}}。\n$$\n如果 $s_n$ 收斂，那麼定義，\n$$\n[a_0;a_1,a_2,...]:=\\lim_{i\\rightarrow\\infty}s_n。\n$$\n\n### 如何計算\n\n**從連分數算出質因子表達式**\n\n定義\n$$\n\\frac{p_i}{q_i}=[a_0;a_1,...a_i]，\n$$\n其中 $p_i, q_i$ 互質，那麼我們有遞推關係\n$$\np_n=a_n\\cdot p_{n-1}+p_{n-2}\\\\\\\nq_n=a_n\\cdot q_{n-1}+q_{n-2}\n$$\n\n\n**從實數構造出連分數表達式**\n\n任何實數 $r\\in\\mathbb{R}$ 都可以被連分數序列表達，\n$$\nr = [a_0;a_1,...]。\n$$\n並且考慮\n$$\nr_0 = r\\\\\\\nr_n=\\frac{1}{r_{n-1}-a_{n-1}}，\n$$\n那麼我們有\n$$\na_n=\\lfloor r_n\\rfloor。\n$$\n\n\n**表達的唯一性**\n\n考慮\n$$\ns = [a_0;a_1,...,a_n+1] = [a_0;a_1,...,a_n,1]，\n$$\n除去這種情況外，連分數的表達是唯一的。\n\n### 有理逼近\n\n考慮我們想要逼近區間 $[l,r),r=l+1\\in\\mathbb{Z}$ 之間的某個數字 $x$，模仿二分逼近法，我們可以先定義一個\"中值函數\"\n$$\nmid(\\frac{a}{b},\\frac{c}{d})=\\frac{a+c}{b+d}。\n$$\n如果\n$$\n\\frac{a}{b}<\\frac{c}{d}，\n$$\n那麼顯然有\n$$\n\\frac{a}{b}<mid(\\frac{a}{b},\\frac{c}{d})<\\frac{c}{d}。\n$$\n可以透過下面迭代使解收斂至 $x$\n$$\nm_i = mid(l_i,r_i)\\\\\n\\pmatrix{l_0\\\\r_0} = \\pmatrix{l\\\\r}\\\\\n\\pmatrix{l_{i+1}\\\\r_{i+1}} = \\pmatrix{m_i\\\\r_i},m_i<x\\\\\n\\pmatrix{l_{i+1}\\\\r_{i+1}} = \\pmatrix{l_i\\\\m_i},x<m_i\n$$\n\n仔細觀察 $mid$ 函數，其實正對應到連分數的迭代式，\n如果\n$$\nl_i = [a_0;a_1,a_2,...,a_{i-2}]\\\\\nr_i = [a_0;a_1,a_2,...,a_{i-1}]\n$$\n那麼有\n$$\nmid(l_i, r_i) = [a_0;a_1,a_2,...,a_{i-1},1] = [a_0;a_1,a_2,...,a_{i-1}+1]\n$$\n可以發現對於數列這樣一個迭代的數列中類似於連分數，結論上兩種序列最終都會收斂至 $x$ (需要證明)，但連分數的收斂速度更快。\n\n### Optimal Diophantine Approximation\n\n事實證明，連分數序列不只會收斂至指定的實數，這個序列是某種意義下的最佳逼近。\n\n對於 $x\\in\\mathbb{R}$ 考慮 $N\\in\\mathbb{N}$ ，那麼對於所有質因子表達，\n$$\n\\frac{p}{q}, q<N\n$$\n總存在\n$$\n\\frac{p_n}{q_n}=[a_0;a_1,a_2,...,a_n],\\\\\n|\\frac{p_n}{q_n}-x|\\leq|\\frac{p}{q}-x|。\n$$\n\n此外，由於連分數的分子分母項都是指數成長(從遞推式可以看出)，計算上它是十分有效率的，可以說這是一個相當好的逼近方法。\n\n### 後記\n然後我就把手邊的 double A4拿去做實驗XD，發現它的長寬比大概是24:17\n![](https://i.imgur.com/LOJPbkz.png)\n","source":"_posts/Quick-Note-on-the-Continued-Fraction.md","raw":"---\ntitle: Quick Note on the Continued Fraction\ndate: 2018-11-24 03:07:49\ntags:\n---\n<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script\n    src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async>\n</script>\n\n本文將簡述連分數，有些內容之後視情況將斟酌補充。\n\n![](https://i.imgur.com/Tht0evZ.png)\n\n連分數在數學上是一個有趣的主題，小時候大家玩過摺紙遊戲，把長方形的紙片等角對折，剪去以折線為對角的正方形，然後不斷重複做一樣的事情之後，把同樣大小的正方形蒐集起來，這時候正方形由大到小的個數就構成了一個連分數。\n\n\n### Definition\n\n考慮一串整數的序列，\n$$\na_0,a_1,a_2,...\n$$\n其中 $a_i\\geq 0,\\forall i>0$。\n我們定義有限項連分數，\n$$\ns_n=[a_0;a_1,a_2,...,a_n]:=a_0+\\frac{1}{a_1+\\frac{1}{a_2+\\frac{...}{a_n}}}。\n$$\n如果 $s_n$ 收斂，那麼定義，\n$$\n[a_0;a_1,a_2,...]:=\\lim_{i\\rightarrow\\infty}s_n。\n$$\n\n### 如何計算\n\n**從連分數算出質因子表達式**\n\n定義\n$$\n\\frac{p_i}{q_i}=[a_0;a_1,...a_i]，\n$$\n其中 $p_i, q_i$ 互質，那麼我們有遞推關係\n$$\np_n=a_n\\cdot p_{n-1}+p_{n-2}\\\\\\\nq_n=a_n\\cdot q_{n-1}+q_{n-2}\n$$\n\n\n**從實數構造出連分數表達式**\n\n任何實數 $r\\in\\mathbb{R}$ 都可以被連分數序列表達，\n$$\nr = [a_0;a_1,...]。\n$$\n並且考慮\n$$\nr_0 = r\\\\\\\nr_n=\\frac{1}{r_{n-1}-a_{n-1}}，\n$$\n那麼我們有\n$$\na_n=\\lfloor r_n\\rfloor。\n$$\n\n\n**表達的唯一性**\n\n考慮\n$$\ns = [a_0;a_1,...,a_n+1] = [a_0;a_1,...,a_n,1]，\n$$\n除去這種情況外，連分數的表達是唯一的。\n\n### 有理逼近\n\n考慮我們想要逼近區間 $[l,r),r=l+1\\in\\mathbb{Z}$ 之間的某個數字 $x$，模仿二分逼近法，我們可以先定義一個\"中值函數\"\n$$\nmid(\\frac{a}{b},\\frac{c}{d})=\\frac{a+c}{b+d}。\n$$\n如果\n$$\n\\frac{a}{b}<\\frac{c}{d}，\n$$\n那麼顯然有\n$$\n\\frac{a}{b}<mid(\\frac{a}{b},\\frac{c}{d})<\\frac{c}{d}。\n$$\n可以透過下面迭代使解收斂至 $x$\n$$\nm_i = mid(l_i,r_i)\\\\\n\\pmatrix{l_0\\\\r_0} = \\pmatrix{l\\\\r}\\\\\n\\pmatrix{l_{i+1}\\\\r_{i+1}} = \\pmatrix{m_i\\\\r_i},m_i<x\\\\\n\\pmatrix{l_{i+1}\\\\r_{i+1}} = \\pmatrix{l_i\\\\m_i},x<m_i\n$$\n\n仔細觀察 $mid$ 函數，其實正對應到連分數的迭代式，\n如果\n$$\nl_i = [a_0;a_1,a_2,...,a_{i-2}]\\\\\nr_i = [a_0;a_1,a_2,...,a_{i-1}]\n$$\n那麼有\n$$\nmid(l_i, r_i) = [a_0;a_1,a_2,...,a_{i-1},1] = [a_0;a_1,a_2,...,a_{i-1}+1]\n$$\n可以發現對於數列這樣一個迭代的數列中類似於連分數，結論上兩種序列最終都會收斂至 $x$ (需要證明)，但連分數的收斂速度更快。\n\n### Optimal Diophantine Approximation\n\n事實證明，連分數序列不只會收斂至指定的實數，這個序列是某種意義下的最佳逼近。\n\n對於 $x\\in\\mathbb{R}$ 考慮 $N\\in\\mathbb{N}$ ，那麼對於所有質因子表達，\n$$\n\\frac{p}{q}, q<N\n$$\n總存在\n$$\n\\frac{p_n}{q_n}=[a_0;a_1,a_2,...,a_n],\\\\\n|\\frac{p_n}{q_n}-x|\\leq|\\frac{p}{q}-x|。\n$$\n\n此外，由於連分數的分子分母項都是指數成長(從遞推式可以看出)，計算上它是十分有效率的，可以說這是一個相當好的逼近方法。\n\n### 後記\n然後我就把手邊的 double A4拿去做實驗XD，發現它的長寬比大概是24:17\n![](https://i.imgur.com/LOJPbkz.png)\n","slug":"Quick-Note-on-the-Continued-Fraction","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mp8000fbx4rafhih6xn","content":"<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML\" async>\n</script>\n\n<p>本文將簡述連分數，有些內容之後視情況將斟酌補充。</p>\n<p><img src=\"https://i.imgur.com/Tht0evZ.png\" alt=\"\"></p>\n<p>連分數在數學上是一個有趣的主題，小時候大家玩過摺紙遊戲，把長方形的紙片等角對折，剪去以折線為對角的正方形，然後不斷重複做一樣的事情之後，把同樣大小的正方形蒐集起來，這時候正方形由大到小的個數就構成了一個連分數。</p>\n<h3 id=\"Definition\"><a href=\"#Definition\" class=\"headerlink\" title=\"Definition\"></a>Definition</h3><p>考慮一串整數的序列，<br>$$<br>a_0,a_1,a_2,…<br>$$<br>其中 $a_i\\geq 0,\\forall i&gt;0$。<br>我們定義有限項連分數，<br>$$<br>s_n=[a_0;a_1,a_2,…,a_n]:=a_0+\\frac{1}{a_1+\\frac{1}{a_2+\\frac{…}{a_n}}}。<br>$$<br>如果 $s_n$ 收斂，那麼定義，<br>$$<br>[a_0;a_1,a_2,…]:=\\lim_{i\\rightarrow\\infty}s_n。<br>$$</p>\n<h3 id=\"如何計算\"><a href=\"#如何計算\" class=\"headerlink\" title=\"如何計算\"></a>如何計算</h3><p><strong>從連分數算出質因子表達式</strong></p>\n<p>定義<br>$$<br>\\frac{p_i}{q_i}=[a_0;a_1,…a_i]，<br>$$<br>其中 $p_i, q_i$ 互質，那麼我們有遞推關係<br>$$<br>p_n=a_n\\cdot p_{n-1}+p_{n-2}\\\\\\<br>q_n=a_n\\cdot q_{n-1}+q_{n-2}<br>$$</p>\n<p><strong>從實數構造出連分數表達式</strong></p>\n<p>任何實數 $r\\in\\mathbb{R}$ 都可以被連分數序列表達，<br>$$<br>r = [a_0;a_1,…]。<br>$$<br>並且考慮<br>$$<br>r_0 = r\\\\\\<br>r_n=\\frac{1}{r_{n-1}-a_{n-1}}，<br>$$<br>那麼我們有<br>$$<br>a_n=\\lfloor r_n\\rfloor。<br>$$</p>\n<p><strong>表達的唯一性</strong></p>\n<p>考慮<br>$$<br>s = [a_0;a_1,…,a_n+1] = [a_0;a_1,…,a_n,1]，<br>$$<br>除去這種情況外，連分數的表達是唯一的。</p>\n<h3 id=\"有理逼近\"><a href=\"#有理逼近\" class=\"headerlink\" title=\"有理逼近\"></a>有理逼近</h3><p>考慮我們想要逼近區間 $[l,r),r=l+1\\in\\mathbb{Z}$ 之間的某個數字 $x$，模仿二分逼近法，我們可以先定義一個”中值函數”<br>$$<br>mid(\\frac{a}{b},\\frac{c}{d})=\\frac{a+c}{b+d}。<br>$$<br>如果<br>$$<br>\\frac{a}{b}&lt;\\frac{c}{d}，<br>$$<br>那麼顯然有<br>$$<br>\\frac{a}{b}&lt;mid(\\frac{a}{b},\\frac{c}{d})&lt;\\frac{c}{d}。<br>$$<br>可以透過下面迭代使解收斂至 $x$<br>$$<br>m_i = mid(l_i,r_i)\\\\<br>\\pmatrix{l_0\\\\r_0} = \\pmatrix{l\\\\r}\\\\<br>\\pmatrix{l_{i+1}\\\\r_{i+1}} = \\pmatrix{m_i\\\\r_i},m_i&lt;x\\\\<br>\\pmatrix{l_{i+1}\\\\r_{i+1}} = \\pmatrix{l_i\\\\m_i},x&lt;m_i<br>$$</p>\n<p>仔細觀察 $mid$ 函數，其實正對應到連分數的迭代式，<br>如果<br>$$<br>l_i = [a_0;a_1,a_2,…,a_{i-2}]\\\\<br>r_i = [a_0;a_1,a_2,…,a_{i-1}]<br>$$<br>那麼有<br>$$<br>mid(l_i, r_i) = [a_0;a_1,a_2,…,a_{i-1},1] = [a_0;a_1,a_2,…,a_{i-1}+1]<br>$$<br>可以發現對於數列這樣一個迭代的數列中類似於連分數，結論上兩種序列最終都會收斂至 $x$ (需要證明)，但連分數的收斂速度更快。</p>\n<h3 id=\"Optimal-Diophantine-Approximation\"><a href=\"#Optimal-Diophantine-Approximation\" class=\"headerlink\" title=\"Optimal Diophantine Approximation\"></a>Optimal Diophantine Approximation</h3><p>事實證明，連分數序列不只會收斂至指定的實數，這個序列是某種意義下的最佳逼近。</p>\n<p>對於 $x\\in\\mathbb{R}$ 考慮 $N\\in\\mathbb{N}$ ，那麼對於所有質因子表達，<br>$$<br>\\frac{p}{q}, q&lt;N<br>$$<br>總存在<br>$$<br>\\frac{p_n}{q_n}=[a_0;a_1,a_2,…,a_n],\\\\<br>|\\frac{p_n}{q_n}-x|\\leq|\\frac{p}{q}-x|。<br>$$</p>\n<p>此外，由於連分數的分子分母項都是指數成長(從遞推式可以看出)，計算上它是十分有效率的，可以說這是一個相當好的逼近方法。</p>\n<h3 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h3><p>然後我就把手邊的 double A4拿去做實驗XD，發現它的長寬比大概是24:17<br><img src=\"https://i.imgur.com/LOJPbkz.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<script type=\"text/x-mathjax-config\">\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n      processEscapes: true\n    }\n  });\n</script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML\" async>\n</script>\n\n<p>本文將簡述連分數，有些內容之後視情況將斟酌補充。</p>\n<p><img src=\"https://i.imgur.com/Tht0evZ.png\" alt=\"\"></p>\n<p>連分數在數學上是一個有趣的主題，小時候大家玩過摺紙遊戲，把長方形的紙片等角對折，剪去以折線為對角的正方形，然後不斷重複做一樣的事情之後，把同樣大小的正方形蒐集起來，這時候正方形由大到小的個數就構成了一個連分數。</p>\n<h3 id=\"Definition\"><a href=\"#Definition\" class=\"headerlink\" title=\"Definition\"></a>Definition</h3><p>考慮一串整數的序列，<br>$$<br>a_0,a_1,a_2,…<br>$$<br>其中 $a_i\\geq 0,\\forall i&gt;0$。<br>我們定義有限項連分數，<br>$$<br>s_n=[a_0;a_1,a_2,…,a_n]:=a_0+\\frac{1}{a_1+\\frac{1}{a_2+\\frac{…}{a_n}}}。<br>$$<br>如果 $s_n$ 收斂，那麼定義，<br>$$<br>[a_0;a_1,a_2,…]:=\\lim_{i\\rightarrow\\infty}s_n。<br>$$</p>\n<h3 id=\"如何計算\"><a href=\"#如何計算\" class=\"headerlink\" title=\"如何計算\"></a>如何計算</h3><p><strong>從連分數算出質因子表達式</strong></p>\n<p>定義<br>$$<br>\\frac{p_i}{q_i}=[a_0;a_1,…a_i]，<br>$$<br>其中 $p_i, q_i$ 互質，那麼我們有遞推關係<br>$$<br>p_n=a_n\\cdot p_{n-1}+p_{n-2}\\\\\\<br>q_n=a_n\\cdot q_{n-1}+q_{n-2}<br>$$</p>\n<p><strong>從實數構造出連分數表達式</strong></p>\n<p>任何實數 $r\\in\\mathbb{R}$ 都可以被連分數序列表達，<br>$$<br>r = [a_0;a_1,…]。<br>$$<br>並且考慮<br>$$<br>r_0 = r\\\\\\<br>r_n=\\frac{1}{r_{n-1}-a_{n-1}}，<br>$$<br>那麼我們有<br>$$<br>a_n=\\lfloor r_n\\rfloor。<br>$$</p>\n<p><strong>表達的唯一性</strong></p>\n<p>考慮<br>$$<br>s = [a_0;a_1,…,a_n+1] = [a_0;a_1,…,a_n,1]，<br>$$<br>除去這種情況外，連分數的表達是唯一的。</p>\n<h3 id=\"有理逼近\"><a href=\"#有理逼近\" class=\"headerlink\" title=\"有理逼近\"></a>有理逼近</h3><p>考慮我們想要逼近區間 $[l,r),r=l+1\\in\\mathbb{Z}$ 之間的某個數字 $x$，模仿二分逼近法，我們可以先定義一個”中值函數”<br>$$<br>mid(\\frac{a}{b},\\frac{c}{d})=\\frac{a+c}{b+d}。<br>$$<br>如果<br>$$<br>\\frac{a}{b}&lt;\\frac{c}{d}，<br>$$<br>那麼顯然有<br>$$<br>\\frac{a}{b}&lt;mid(\\frac{a}{b},\\frac{c}{d})&lt;\\frac{c}{d}。<br>$$<br>可以透過下面迭代使解收斂至 $x$<br>$$<br>m_i = mid(l_i,r_i)\\\\<br>\\pmatrix{l_0\\\\r_0} = \\pmatrix{l\\\\r}\\\\<br>\\pmatrix{l_{i+1}\\\\r_{i+1}} = \\pmatrix{m_i\\\\r_i},m_i&lt;x\\\\<br>\\pmatrix{l_{i+1}\\\\r_{i+1}} = \\pmatrix{l_i\\\\m_i},x&lt;m_i<br>$$</p>\n<p>仔細觀察 $mid$ 函數，其實正對應到連分數的迭代式，<br>如果<br>$$<br>l_i = [a_0;a_1,a_2,…,a_{i-2}]\\\\<br>r_i = [a_0;a_1,a_2,…,a_{i-1}]<br>$$<br>那麼有<br>$$<br>mid(l_i, r_i) = [a_0;a_1,a_2,…,a_{i-1},1] = [a_0;a_1,a_2,…,a_{i-1}+1]<br>$$<br>可以發現對於數列這樣一個迭代的數列中類似於連分數，結論上兩種序列最終都會收斂至 $x$ (需要證明)，但連分數的收斂速度更快。</p>\n<h3 id=\"Optimal-Diophantine-Approximation\"><a href=\"#Optimal-Diophantine-Approximation\" class=\"headerlink\" title=\"Optimal Diophantine Approximation\"></a>Optimal Diophantine Approximation</h3><p>事實證明，連分數序列不只會收斂至指定的實數，這個序列是某種意義下的最佳逼近。</p>\n<p>對於 $x\\in\\mathbb{R}$ 考慮 $N\\in\\mathbb{N}$ ，那麼對於所有質因子表達，<br>$$<br>\\frac{p}{q}, q&lt;N<br>$$<br>總存在<br>$$<br>\\frac{p_n}{q_n}=[a_0;a_1,a_2,…,a_n],\\\\<br>|\\frac{p_n}{q_n}-x|\\leq|\\frac{p}{q}-x|。<br>$$</p>\n<p>此外，由於連分數的分子分母項都是指數成長(從遞推式可以看出)，計算上它是十分有效率的，可以說這是一個相當好的逼近方法。</p>\n<h3 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h3><p>然後我就把手邊的 double A4拿去做實驗XD，發現它的長寬比大概是24:17<br><img src=\"https://i.imgur.com/LOJPbkz.png\" alt=\"\"></p>\n"},{"title":"Randomized Primality Test","date":"2019-03-22T21:07:54.000Z","_content":"\nPrimality testing is a computational problem that determines whether a given integer $n$ is prime or composite.\n$$\nPRIMES:=\\{p\\in\\mathbb{N}:\\forall n<p, n\\nmid p\\}\n$$\n\nBelow we enlist several primality testing algorithm, and will ellaborate one BPP variant of the Miller-Rabin test.\n\n### Theorem [Strassen, Solovay] \n$$\nPRIMES\\in coRP\n$$\nOn input $n\\in\\mathbb{N}$, \n- randomly pick $a\\in\\mathbb{Z}_n$\n- compute the legendre symbol $\\pmatrix{\\frac{a}{n}}$\n- if $\\pmatrix{\\frac{a}{n}}$ = 0 or $a^{(n-1)/2}$, reject; otherwise, accept.\n\n### Theorem [Miller, Rabin]\n$$\nPRIMES\\in coRP\n$$\nOn input $n\\in\\mathbb{Z}$,\n- randomly pick $a\\in\\mathbb{Z}_n^\\times$\n- assume $n=r\\cdot 2^k$, $r$ is odd\n- accept if and only if the following holds\n    - $a^r=1$\n    - $\\exists l<k, a^{r\\cdot 2^l}=-1$\n\nWe leave the proof to [this article](https://asd00012334.github.io/2019/03/25/Miller-Rabin-Primality-Test/).\n\n### Theorem [Agrawal, Kayal, Saxena]\n$$\nPRIMES\\in P\n$$\n\n---\n\nWe are going to prove a weaker version of the above theorem, which gives a $BPP$ algorithm. Note that\n$$\nP\\subseteq coRP\\subseteq BPP\n$$\nThe algorithm we're going to prove could be slighly modified to elliminate error at one side. In practice, the Miller-Rabin test is most oftenly used. Below we are going to ignore the fact that a uniform random number shall be approximated, instead we uses a exact random variable to make our analysis easier, since it will not affect much.\n\n### Theorem\n$$\nPRIMES\\in BPP\n$$\n\n**proof.** \n\nTo prove $PRIMES\\in BPP$, consider the following algorithm.\n\nOn input $n\\in\\mathbb{Z}$,\n- reject even numbers (assume n is odd)\n- randomly pick $a_i\\in\\mathbb{Z}_n^\\times$ for $1\\leq i\\leq t$\n- compute sequence $\\{a_i^{(n-1)/2}:1\\leq i\\leq t\\}$\n    - if it is not all $\\pm 1$, reject\n    - if of form 1,1,...,1, reject\n    - otherwise, accept\n\nThe time complexity for this algorithm is clearly polynomial w.r.t. input length. We only need to show its correctness, i.e. it makes the right decision with high probability.\n\n*Sufficiency*\nIf $n$ is prime, then by Fermat's little theorem,\n$$\na^{(n-1)/2} = \\pm 1.\n$$\nSince $\\mathbb{Z}_n^\\times=\\langle\\alpha\\rangle$ is cyclic, we have,\n$$\na^{(n-1)/2}=-1 \\iff a\\not\\in\\langle\\alpha^2\\rangle.\n$$\nSo $Pr(a^{(n-1)/2}=-1|a\\in\\mathbb{Z}_n^\\times)=\\frac{1}{2}$, the acceptance probability is $1-2^{-t}$.\n\n*Necessity*\n\nNow that we assume $n$ is composite, if $gcd(a,n)>1$, we just naturally reject $n$. We want to show that with high probability the sequence will contain non-$\\pm 1$.\n\n- Case $n=m_1m_2$, co-prime proper factoring.\n\nConsider the following subsets,\n$$\nS_+:=\\{a\\in\\mathbb{Z}_n^{\\times}: a^{(n-1)/2}=1\\},\\\\\nS_{-}:=\\{a\\in\\mathbb{Z}_n^{\\times}: a^{(n-1)/2}=-1\\}.\n$$\n\nIf $S_{-}$ is empty, then the algorithm certainly reject. Otherwise, assume $b\\in S_{-}$, and of course $1\\in S_+$.\n\n\nBy Chinese remainder theorem,\n$$\n\\mathbb{Z}_{n}\\cong\\mathbb{Z}_{m_1}\\times\\mathbb{Z}_{m_2}.\n$$\nPick $c\\mapsto (1,b)$ by the above isomorphism. Then\n$$\nc^{(n-1)/2}\\mapsto (1,-1),\n$$\ntherefore $c^{(n-1)/2}\\not\\in S:=S_+\\cup S_-$, then $S_+\\subsetneq S\\subsetneq \\mathbb{Z}_n$. Since multiplication is closed under $S, S_+$, both are proper subgroups. By Lagrange theorem, $|S|\\leq \\frac{\\phi(n)}{2}$. Therefore\n$$\nPr(\\exists i,a_i^{(n-1)/2}\\neq\\pm 1)\\geq 1-2^{-t},\n$$\nis a lower bound for the rejection probability.\n\n- Case $n = p^e$, prime power.\n\nSince $\\mathbb{Z}_n^\\times=\\langle\\alpha\\rangle$ is cyclic, assume $a=\\alpha^k$. We have,\n$$\na^{(n-1)/2}=\\pm 1\\mod n\\\\\n\\Rightarrow \\alpha^{k(n-1)}= 1\\\\\n\\Rightarrow k(n-1)=0\\mod\\phi(n)\n$$\nSince $n-1=p^e-1=(p-1)(1+p+p^2+...p^{e-1})$ and $\\phi(n)=p^e-p^{e-1}.$\nThe above implies that\n$$\nk(1+p+...+p^{e-1})=0\\mod p^{e-1}\\\\\n\\Rightarrow k=0\\mod p^{e-1}\n$$\nTherefore $Pr(a=\\pm 1)\\leq Pr(k=0\\mod p^{e-1})=\\frac{1}{p^{e-1}}\\leq\\frac{1}{2}$. So a lower bound for the rejection probability is $1-2^{-t}$. $_\\Box$\n\n","source":"_posts/Randomized-Primality-Test.md","raw":"---\ntitle: Randomized Primality Test\ndate: 2019-03-22 22:07:54\ntags:\n- prime\n- complexity\n---\n\nPrimality testing is a computational problem that determines whether a given integer $n$ is prime or composite.\n$$\nPRIMES:=\\{p\\in\\mathbb{N}:\\forall n<p, n\\nmid p\\}\n$$\n\nBelow we enlist several primality testing algorithm, and will ellaborate one BPP variant of the Miller-Rabin test.\n\n### Theorem [Strassen, Solovay] \n$$\nPRIMES\\in coRP\n$$\nOn input $n\\in\\mathbb{N}$, \n- randomly pick $a\\in\\mathbb{Z}_n$\n- compute the legendre symbol $\\pmatrix{\\frac{a}{n}}$\n- if $\\pmatrix{\\frac{a}{n}}$ = 0 or $a^{(n-1)/2}$, reject; otherwise, accept.\n\n### Theorem [Miller, Rabin]\n$$\nPRIMES\\in coRP\n$$\nOn input $n\\in\\mathbb{Z}$,\n- randomly pick $a\\in\\mathbb{Z}_n^\\times$\n- assume $n=r\\cdot 2^k$, $r$ is odd\n- accept if and only if the following holds\n    - $a^r=1$\n    - $\\exists l<k, a^{r\\cdot 2^l}=-1$\n\nWe leave the proof to [this article](https://asd00012334.github.io/2019/03/25/Miller-Rabin-Primality-Test/).\n\n### Theorem [Agrawal, Kayal, Saxena]\n$$\nPRIMES\\in P\n$$\n\n---\n\nWe are going to prove a weaker version of the above theorem, which gives a $BPP$ algorithm. Note that\n$$\nP\\subseteq coRP\\subseteq BPP\n$$\nThe algorithm we're going to prove could be slighly modified to elliminate error at one side. In practice, the Miller-Rabin test is most oftenly used. Below we are going to ignore the fact that a uniform random number shall be approximated, instead we uses a exact random variable to make our analysis easier, since it will not affect much.\n\n### Theorem\n$$\nPRIMES\\in BPP\n$$\n\n**proof.** \n\nTo prove $PRIMES\\in BPP$, consider the following algorithm.\n\nOn input $n\\in\\mathbb{Z}$,\n- reject even numbers (assume n is odd)\n- randomly pick $a_i\\in\\mathbb{Z}_n^\\times$ for $1\\leq i\\leq t$\n- compute sequence $\\{a_i^{(n-1)/2}:1\\leq i\\leq t\\}$\n    - if it is not all $\\pm 1$, reject\n    - if of form 1,1,...,1, reject\n    - otherwise, accept\n\nThe time complexity for this algorithm is clearly polynomial w.r.t. input length. We only need to show its correctness, i.e. it makes the right decision with high probability.\n\n*Sufficiency*\nIf $n$ is prime, then by Fermat's little theorem,\n$$\na^{(n-1)/2} = \\pm 1.\n$$\nSince $\\mathbb{Z}_n^\\times=\\langle\\alpha\\rangle$ is cyclic, we have,\n$$\na^{(n-1)/2}=-1 \\iff a\\not\\in\\langle\\alpha^2\\rangle.\n$$\nSo $Pr(a^{(n-1)/2}=-1|a\\in\\mathbb{Z}_n^\\times)=\\frac{1}{2}$, the acceptance probability is $1-2^{-t}$.\n\n*Necessity*\n\nNow that we assume $n$ is composite, if $gcd(a,n)>1$, we just naturally reject $n$. We want to show that with high probability the sequence will contain non-$\\pm 1$.\n\n- Case $n=m_1m_2$, co-prime proper factoring.\n\nConsider the following subsets,\n$$\nS_+:=\\{a\\in\\mathbb{Z}_n^{\\times}: a^{(n-1)/2}=1\\},\\\\\nS_{-}:=\\{a\\in\\mathbb{Z}_n^{\\times}: a^{(n-1)/2}=-1\\}.\n$$\n\nIf $S_{-}$ is empty, then the algorithm certainly reject. Otherwise, assume $b\\in S_{-}$, and of course $1\\in S_+$.\n\n\nBy Chinese remainder theorem,\n$$\n\\mathbb{Z}_{n}\\cong\\mathbb{Z}_{m_1}\\times\\mathbb{Z}_{m_2}.\n$$\nPick $c\\mapsto (1,b)$ by the above isomorphism. Then\n$$\nc^{(n-1)/2}\\mapsto (1,-1),\n$$\ntherefore $c^{(n-1)/2}\\not\\in S:=S_+\\cup S_-$, then $S_+\\subsetneq S\\subsetneq \\mathbb{Z}_n$. Since multiplication is closed under $S, S_+$, both are proper subgroups. By Lagrange theorem, $|S|\\leq \\frac{\\phi(n)}{2}$. Therefore\n$$\nPr(\\exists i,a_i^{(n-1)/2}\\neq\\pm 1)\\geq 1-2^{-t},\n$$\nis a lower bound for the rejection probability.\n\n- Case $n = p^e$, prime power.\n\nSince $\\mathbb{Z}_n^\\times=\\langle\\alpha\\rangle$ is cyclic, assume $a=\\alpha^k$. We have,\n$$\na^{(n-1)/2}=\\pm 1\\mod n\\\\\n\\Rightarrow \\alpha^{k(n-1)}= 1\\\\\n\\Rightarrow k(n-1)=0\\mod\\phi(n)\n$$\nSince $n-1=p^e-1=(p-1)(1+p+p^2+...p^{e-1})$ and $\\phi(n)=p^e-p^{e-1}.$\nThe above implies that\n$$\nk(1+p+...+p^{e-1})=0\\mod p^{e-1}\\\\\n\\Rightarrow k=0\\mod p^{e-1}\n$$\nTherefore $Pr(a=\\pm 1)\\leq Pr(k=0\\mod p^{e-1})=\\frac{1}{p^{e-1}}\\leq\\frac{1}{2}$. So a lower bound for the rejection probability is $1-2^{-t}$. $_\\Box$\n\n","slug":"Randomized-Primality-Test","published":1,"updated":"2024-05-27T19:29:40.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mp9000gbx4r7ppj3v9p","content":"<p>Primality testing is a computational problem that determines whether a given integer $n$ is prime or composite.<br>$$<br>PRIMES:=\\{p\\in\\mathbb{N}:\\forall n&lt;p, n\\nmid p\\}<br>$$</p>\n<p>Below we enlist several primality testing algorithm, and will ellaborate one BPP variant of the Miller-Rabin test.</p>\n<h3 id=\"Theorem-Strassen-Solovay\"><a href=\"#Theorem-Strassen-Solovay\" class=\"headerlink\" title=\"Theorem [Strassen, Solovay]\"></a>Theorem [Strassen, Solovay]</h3><p>$$<br>PRIMES\\in coRP<br>$$<br>On input $n\\in\\mathbb{N}$, </p>\n<ul>\n<li>randomly pick $a\\in\\mathbb{Z}_n$</li>\n<li>compute the legendre symbol $\\pmatrix{\\frac{a}{n}}$</li>\n<li>if $\\pmatrix{\\frac{a}{n}}$ = 0 or $a^{(n-1)/2}$, reject; otherwise, accept.</li>\n</ul>\n<h3 id=\"Theorem-Miller-Rabin\"><a href=\"#Theorem-Miller-Rabin\" class=\"headerlink\" title=\"Theorem [Miller, Rabin]\"></a>Theorem [Miller, Rabin]</h3><p>$$<br>PRIMES\\in coRP<br>$$<br>On input $n\\in\\mathbb{Z}$,</p>\n<ul>\n<li>randomly pick $a\\in\\mathbb{Z}_n^\\times$</li>\n<li>assume $n=r\\cdot 2^k$, $r$ is odd</li>\n<li>accept if and only if the following holds<ul>\n<li>$a^r=1$</li>\n<li>$\\exists l&lt;k, a^{r\\cdot 2^l}=-1$</li>\n</ul>\n</li>\n</ul>\n<p>We leave the proof to <a href=\"https://asd00012334.github.io/2019/03/25/Miller-Rabin-Primality-Test/\">this article</a>.</p>\n<h3 id=\"Theorem-Agrawal-Kayal-Saxena\"><a href=\"#Theorem-Agrawal-Kayal-Saxena\" class=\"headerlink\" title=\"Theorem [Agrawal, Kayal, Saxena]\"></a>Theorem [Agrawal, Kayal, Saxena]</h3><p>$$<br>PRIMES\\in P<br>$$</p>\n<hr>\n<p>We are going to prove a weaker version of the above theorem, which gives a $BPP$ algorithm. Note that<br>$$<br>P\\subseteq coRP\\subseteq BPP<br>$$<br>The algorithm we’re going to prove could be slighly modified to elliminate error at one side. In practice, the Miller-Rabin test is most oftenly used. Below we are going to ignore the fact that a uniform random number shall be approximated, instead we uses a exact random variable to make our analysis easier, since it will not affect much.</p>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>$$<br>PRIMES\\in BPP<br>$$</p>\n<p><strong>proof.</strong> </p>\n<p>To prove $PRIMES\\in BPP$, consider the following algorithm.</p>\n<p>On input $n\\in\\mathbb{Z}$,</p>\n<ul>\n<li>reject even numbers (assume n is odd)</li>\n<li>randomly pick $a_i\\in\\mathbb{Z}_n^\\times$ for $1\\leq i\\leq t$</li>\n<li>compute sequence $\\{a_i^{(n-1)/2}:1\\leq i\\leq t\\}$<ul>\n<li>if it is not all $\\pm 1$, reject</li>\n<li>if of form 1,1,…,1, reject</li>\n<li>otherwise, accept</li>\n</ul>\n</li>\n</ul>\n<p>The time complexity for this algorithm is clearly polynomial w.r.t. input length. We only need to show its correctness, i.e. it makes the right decision with high probability.</p>\n<p><em>Sufficiency</em><br>If $n$ is prime, then by Fermat’s little theorem,<br>$$<br>a^{(n-1)/2} = \\pm 1.<br>$$<br>Since $\\mathbb{Z}_n^\\times=\\langle\\alpha\\rangle$ is cyclic, we have,<br>$$<br>a^{(n-1)/2}=-1 \\iff a\\not\\in\\langle\\alpha^2\\rangle.<br>$$<br>So $Pr(a^{(n-1)/2}=-1|a\\in\\mathbb{Z}_n^\\times)=\\frac{1}{2}$, the acceptance probability is $1-2^{-t}$.</p>\n<p><em>Necessity</em></p>\n<p>Now that we assume $n$ is composite, if $gcd(a,n)&gt;1$, we just naturally reject $n$. We want to show that with high probability the sequence will contain non-$\\pm 1$.</p>\n<ul>\n<li>Case $n=m_1m_2$, co-prime proper factoring.</li>\n</ul>\n<p>Consider the following subsets,<br>$$<br>S_+:=\\{a\\in\\mathbb{Z}_n^{\\times}: a^{(n-1)/2}=1\\},\\\\<br>S_{-}:=\\{a\\in\\mathbb{Z}_n^{\\times}: a^{(n-1)/2}=-1\\}.<br>$$</p>\n<p>If $S_{-}$ is empty, then the algorithm certainly reject. Otherwise, assume $b\\in S_{-}$, and of course $1\\in S_+$.</p>\n<p>By Chinese remainder theorem,<br>$$<br>\\mathbb{Z}_{n}\\cong\\mathbb{Z}_{m_1}\\times\\mathbb{Z}_{m_2}.<br>$$<br>Pick $c\\mapsto (1,b)$ by the above isomorphism. Then<br>$$<br>c^{(n-1)/2}\\mapsto (1,-1),<br>$$<br>therefore $c^{(n-1)/2}\\not\\in S:=S_+\\cup S_-$, then $S_+\\subsetneq S\\subsetneq \\mathbb{Z}_n$. Since multiplication is closed under $S, S_+$, both are proper subgroups. By Lagrange theorem, $|S|\\leq \\frac{\\phi(n)}{2}$. Therefore<br>$$<br>Pr(\\exists i,a_i^{(n-1)/2}\\neq\\pm 1)\\geq 1-2^{-t},<br>$$<br>is a lower bound for the rejection probability.</p>\n<ul>\n<li>Case $n = p^e$, prime power.</li>\n</ul>\n<p>Since $\\mathbb{Z}_n^\\times=\\langle\\alpha\\rangle$ is cyclic, assume $a=\\alpha^k$. We have,<br>$$<br>a^{(n-1)/2}=\\pm 1\\mod n\\\\<br>\\Rightarrow \\alpha^{k(n-1)}= 1\\\\<br>\\Rightarrow k(n-1)=0\\mod\\phi(n)<br>$$<br>Since $n-1=p^e-1=(p-1)(1+p+p^2+…p^{e-1})$ and $\\phi(n)=p^e-p^{e-1}.$<br>The above implies that<br>$$<br>k(1+p+…+p^{e-1})=0\\mod p^{e-1}\\\\<br>\\Rightarrow k=0\\mod p^{e-1}<br>$$<br>Therefore $Pr(a=\\pm 1)\\leq Pr(k=0\\mod p^{e-1})=\\frac{1}{p^{e-1}}\\leq\\frac{1}{2}$. So a lower bound for the rejection probability is $1-2^{-t}$. $_\\Box$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Primality testing is a computational problem that determines whether a given integer $n$ is prime or composite.<br>$$<br>PRIMES:=\\{p\\in\\mathbb{N}:\\forall n&lt;p, n\\nmid p\\}<br>$$</p>\n<p>Below we enlist several primality testing algorithm, and will ellaborate one BPP variant of the Miller-Rabin test.</p>\n<h3 id=\"Theorem-Strassen-Solovay\"><a href=\"#Theorem-Strassen-Solovay\" class=\"headerlink\" title=\"Theorem [Strassen, Solovay]\"></a>Theorem [Strassen, Solovay]</h3><p>$$<br>PRIMES\\in coRP<br>$$<br>On input $n\\in\\mathbb{N}$, </p>\n<ul>\n<li>randomly pick $a\\in\\mathbb{Z}_n$</li>\n<li>compute the legendre symbol $\\pmatrix{\\frac{a}{n}}$</li>\n<li>if $\\pmatrix{\\frac{a}{n}}$ = 0 or $a^{(n-1)/2}$, reject; otherwise, accept.</li>\n</ul>\n<h3 id=\"Theorem-Miller-Rabin\"><a href=\"#Theorem-Miller-Rabin\" class=\"headerlink\" title=\"Theorem [Miller, Rabin]\"></a>Theorem [Miller, Rabin]</h3><p>$$<br>PRIMES\\in coRP<br>$$<br>On input $n\\in\\mathbb{Z}$,</p>\n<ul>\n<li>randomly pick $a\\in\\mathbb{Z}_n^\\times$</li>\n<li>assume $n=r\\cdot 2^k$, $r$ is odd</li>\n<li>accept if and only if the following holds<ul>\n<li>$a^r=1$</li>\n<li>$\\exists l&lt;k, a^{r\\cdot 2^l}=-1$</li>\n</ul>\n</li>\n</ul>\n<p>We leave the proof to <a href=\"https://asd00012334.github.io/2019/03/25/Miller-Rabin-Primality-Test/\">this article</a>.</p>\n<h3 id=\"Theorem-Agrawal-Kayal-Saxena\"><a href=\"#Theorem-Agrawal-Kayal-Saxena\" class=\"headerlink\" title=\"Theorem [Agrawal, Kayal, Saxena]\"></a>Theorem [Agrawal, Kayal, Saxena]</h3><p>$$<br>PRIMES\\in P<br>$$</p>\n<hr>\n<p>We are going to prove a weaker version of the above theorem, which gives a $BPP$ algorithm. Note that<br>$$<br>P\\subseteq coRP\\subseteq BPP<br>$$<br>The algorithm we’re going to prove could be slighly modified to elliminate error at one side. In practice, the Miller-Rabin test is most oftenly used. Below we are going to ignore the fact that a uniform random number shall be approximated, instead we uses a exact random variable to make our analysis easier, since it will not affect much.</p>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>$$<br>PRIMES\\in BPP<br>$$</p>\n<p><strong>proof.</strong> </p>\n<p>To prove $PRIMES\\in BPP$, consider the following algorithm.</p>\n<p>On input $n\\in\\mathbb{Z}$,</p>\n<ul>\n<li>reject even numbers (assume n is odd)</li>\n<li>randomly pick $a_i\\in\\mathbb{Z}_n^\\times$ for $1\\leq i\\leq t$</li>\n<li>compute sequence $\\{a_i^{(n-1)/2}:1\\leq i\\leq t\\}$<ul>\n<li>if it is not all $\\pm 1$, reject</li>\n<li>if of form 1,1,…,1, reject</li>\n<li>otherwise, accept</li>\n</ul>\n</li>\n</ul>\n<p>The time complexity for this algorithm is clearly polynomial w.r.t. input length. We only need to show its correctness, i.e. it makes the right decision with high probability.</p>\n<p><em>Sufficiency</em><br>If $n$ is prime, then by Fermat’s little theorem,<br>$$<br>a^{(n-1)/2} = \\pm 1.<br>$$<br>Since $\\mathbb{Z}_n^\\times=\\langle\\alpha\\rangle$ is cyclic, we have,<br>$$<br>a^{(n-1)/2}=-1 \\iff a\\not\\in\\langle\\alpha^2\\rangle.<br>$$<br>So $Pr(a^{(n-1)/2}=-1|a\\in\\mathbb{Z}_n^\\times)=\\frac{1}{2}$, the acceptance probability is $1-2^{-t}$.</p>\n<p><em>Necessity</em></p>\n<p>Now that we assume $n$ is composite, if $gcd(a,n)&gt;1$, we just naturally reject $n$. We want to show that with high probability the sequence will contain non-$\\pm 1$.</p>\n<ul>\n<li>Case $n=m_1m_2$, co-prime proper factoring.</li>\n</ul>\n<p>Consider the following subsets,<br>$$<br>S_+:=\\{a\\in\\mathbb{Z}_n^{\\times}: a^{(n-1)/2}=1\\},\\\\<br>S_{-}:=\\{a\\in\\mathbb{Z}_n^{\\times}: a^{(n-1)/2}=-1\\}.<br>$$</p>\n<p>If $S_{-}$ is empty, then the algorithm certainly reject. Otherwise, assume $b\\in S_{-}$, and of course $1\\in S_+$.</p>\n<p>By Chinese remainder theorem,<br>$$<br>\\mathbb{Z}_{n}\\cong\\mathbb{Z}_{m_1}\\times\\mathbb{Z}_{m_2}.<br>$$<br>Pick $c\\mapsto (1,b)$ by the above isomorphism. Then<br>$$<br>c^{(n-1)/2}\\mapsto (1,-1),<br>$$<br>therefore $c^{(n-1)/2}\\not\\in S:=S_+\\cup S_-$, then $S_+\\subsetneq S\\subsetneq \\mathbb{Z}_n$. Since multiplication is closed under $S, S_+$, both are proper subgroups. By Lagrange theorem, $|S|\\leq \\frac{\\phi(n)}{2}$. Therefore<br>$$<br>Pr(\\exists i,a_i^{(n-1)/2}\\neq\\pm 1)\\geq 1-2^{-t},<br>$$<br>is a lower bound for the rejection probability.</p>\n<ul>\n<li>Case $n = p^e$, prime power.</li>\n</ul>\n<p>Since $\\mathbb{Z}_n^\\times=\\langle\\alpha\\rangle$ is cyclic, assume $a=\\alpha^k$. We have,<br>$$<br>a^{(n-1)/2}=\\pm 1\\mod n\\\\<br>\\Rightarrow \\alpha^{k(n-1)}= 1\\\\<br>\\Rightarrow k(n-1)=0\\mod\\phi(n)<br>$$<br>Since $n-1=p^e-1=(p-1)(1+p+p^2+…p^{e-1})$ and $\\phi(n)=p^e-p^{e-1}.$<br>The above implies that<br>$$<br>k(1+p+…+p^{e-1})=0\\mod p^{e-1}\\\\<br>\\Rightarrow k=0\\mod p^{e-1}<br>$$<br>Therefore $Pr(a=\\pm 1)\\leq Pr(k=0\\mod p^{e-1})=\\frac{1}{p^{e-1}}\\leq\\frac{1}{2}$. So a lower bound for the rejection probability is $1-2^{-t}$. $_\\Box$</p>\n"},{"title":"新開張","date":"2018-11-16T15:55:50.000Z","_content":"\n## 會寫些什麼\n\n部落格新開張總是要有一篇開張文XD\n這個部落格上的文章多數將會圍繞在數學、計算上展開(誰叫我是讀CS的:P)\n內容主要是平時覺得有趣的東西，或是打比賽遇到的問題。\n\n\n## 舊文去哪裡\n\n以前在hackmd上寫了[不少文章](https://hackmd.io/s/B1w6PhGlm)\n目前還沒有決定這些文章未來會以什麼形式移植到hexo上(或許就留在hackmd)\n嘛~這種事情還是看心情決定好了。\n","source":"_posts/新開張.md","raw":"---\ntitle: 新開張\ndate: 2018-11-16 16:55:50\ntags:\n---\n\n## 會寫些什麼\n\n部落格新開張總是要有一篇開張文XD\n這個部落格上的文章多數將會圍繞在數學、計算上展開(誰叫我是讀CS的:P)\n內容主要是平時覺得有趣的東西，或是打比賽遇到的問題。\n\n\n## 舊文去哪裡\n\n以前在hackmd上寫了[不少文章](https://hackmd.io/s/B1w6PhGlm)\n目前還沒有決定這些文章未來會以什麼形式移植到hexo上(或許就留在hackmd)\n嘛~這種事情還是看心情決定好了。\n","slug":"新開張","published":1,"updated":"2024-05-27T19:29:40.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwpi3mpa000ibx4rg2jfa89n","content":"<h2 id=\"會寫些什麼\"><a href=\"#會寫些什麼\" class=\"headerlink\" title=\"會寫些什麼\"></a>會寫些什麼</h2><p>部落格新開張總是要有一篇開張文XD<br>這個部落格上的文章多數將會圍繞在數學、計算上展開(誰叫我是讀CS的:P)<br>內容主要是平時覺得有趣的東西，或是打比賽遇到的問題。</p>\n<h2 id=\"舊文去哪裡\"><a href=\"#舊文去哪裡\" class=\"headerlink\" title=\"舊文去哪裡\"></a>舊文去哪裡</h2><p>以前在hackmd上寫了<a href=\"https://hackmd.io/s/B1w6PhGlm\" target=\"_blank\" rel=\"noopener\">不少文章</a><br>目前還沒有決定這些文章未來會以什麼形式移植到hexo上(或許就留在hackmd)<br>嘛~這種事情還是看心情決定好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"會寫些什麼\"><a href=\"#會寫些什麼\" class=\"headerlink\" title=\"會寫些什麼\"></a>會寫些什麼</h2><p>部落格新開張總是要有一篇開張文XD<br>這個部落格上的文章多數將會圍繞在數學、計算上展開(誰叫我是讀CS的:P)<br>內容主要是平時覺得有趣的東西，或是打比賽遇到的問題。</p>\n<h2 id=\"舊文去哪裡\"><a href=\"#舊文去哪裡\" class=\"headerlink\" title=\"舊文去哪裡\"></a>舊文去哪裡</h2><p>以前在hackmd上寫了<a href=\"https://hackmd.io/s/B1w6PhGlm\" target=\"_blank\" rel=\"noopener\">不少文章</a><br>目前還沒有決定這些文章未來會以什麼形式移植到hexo上(或許就留在hackmd)<br>嘛~這種事情還是看心情決定好了。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clwpi3moy0002bx4rt99l2vsm","tag_id":"clwpi3mp10006bx4rbt4mqozh","_id":"clwpi3mp6000bbx4resxy76rw"},{"post_id":"clwpi3mp20007bx4rfjgmtc9h","tag_id":"clwpi3mp6000abx4r6qipz3ah","_id":"clwpi3mpa000jbx4rjd0q5xkq"},{"post_id":"clwpi3mp20007bx4rfjgmtc9h","tag_id":"clwpi3mp10006bx4rbt4mqozh","_id":"clwpi3mpa000kbx4regleeg3g"},{"post_id":"clwpi3mp9000gbx4r7ppj3v9p","tag_id":"clwpi3mp6000abx4r6qipz3ah","_id":"clwpi3mpb000mbx4rjl796ebo"},{"post_id":"clwpi3mp9000gbx4r7ppj3v9p","tag_id":"clwpi3mp10006bx4rbt4mqozh","_id":"clwpi3mpb000nbx4r0fqpk9zw"},{"post_id":"clwpi3mp30008bx4ryawoaqb1","tag_id":"clwpi3mp10006bx4rbt4mqozh","_id":"clwpi3mpb000pbx4r1ny8gm5h"},{"post_id":"clwpi3mp30008bx4ryawoaqb1","tag_id":"clwpi3mp9000hbx4r52r8pwsx","_id":"clwpi3mpb000qbx4rr4ss7rq2"},{"post_id":"clwpi3mp40009bx4rpk0mvnp5","tag_id":"clwpi3mpa000lbx4r3ak23mos","_id":"clwpi3mpb000sbx4r49vw3z94"},{"post_id":"clwpi3mp6000cbx4rmslnx34t","tag_id":"clwpi3mp10006bx4rbt4mqozh","_id":"clwpi3mpb000tbx4r4te4dim9"},{"post_id":"clwpi3mp6000cbx4rmslnx34t","tag_id":"clwpi3mpb000obx4rb9xyqco0","_id":"clwpi3mpb000ubx4rwpui631u"},{"post_id":"clwpi3mp6000cbx4rmslnx34t","tag_id":"clwpi3mpb000rbx4rx7ezos7z","_id":"clwpi3mpb000vbx4r6xiqz47t"}],"Tag":[{"name":"complexity","_id":"clwpi3mp10006bx4rbt4mqozh"},{"name":"prime","_id":"clwpi3mp6000abx4r6qipz3ah"},{"name":"communication","_id":"clwpi3mp9000hbx4r52r8pwsx"},{"name":"eigenvalue","_id":"clwpi3mpa000lbx4r3ak23mos"},{"name":"quantum","_id":"clwpi3mpb000obx4rb9xyqco0"},{"name":"query complexity","_id":"clwpi3mpb000rbx4rx7ezos7z"}]}}